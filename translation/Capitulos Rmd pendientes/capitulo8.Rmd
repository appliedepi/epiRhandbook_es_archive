# Limpieza de datos y funciones básicas {#cleaning-data-and-core-functions} 

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Esta página muestra los pasos más utilizados en el proceso de "limpieza" de datos, y también explica el uso de muchas funciones esenciales de gestión de datos en R. 

Para explicarlo, esta página comienza importando datos de un listado de casos crudo, y se avanza paso a paso a través del proceso de limpieza. En el código R, esto se manifiesta como una cadena de "tuberías", que hacen referencia al operador "tuberías" `%>%` que pasa unos datos de una operación a la siguiente. 

## Funciones principales  {.unnumbered}

Este manual hace hincapié en el uso de las funciones de la familia de paquetes de R [**tidyverse**](https://www.tidyverse.org/). Las funciones esenciales que se muestran en esta página se enumeran a continuación. 

Muchas de estas funciones pertenecen al paquete [**dplyr**](https://dplyr.tidyverse.org/), que proporciona funciones "verbales" para resolver los retos de la manipulación de datos (el nombre hace una referencia a unos alicates - [plier](https://www.thefreedictionary.com/plier#:~:text=also ply·er (plī′,holding%2C bending%2C or cutting.)) - de dataframes). **dplyr** forma parte de la familia de paquetes de R **tidyverse** (que también incluye **ggplot2**, **tidyr**, **stringr**, **tibble**, **purrr**, **magrittr** y **forcats**, entre otros). 


Función      | Utilidad                             | Paquete
-------------|--------------------------------------|------------------------------
[%>%](https://magrittr.tidyverse.org/reference/pipe.html) | "canalizar" (pasar) datos de una función a la siguiente | **magrittr**   
[mutate()](https://dplyr.tidyverse.org/reference/mutate.html) | crear, transformar y redefinir columnas | **dplyr**   
[selecct()](https://dplyr.tidyverse.org/reference/select.html) | mantener, eliminar, seleccionar o renombrar columnas | **dplyr**  
[rename()](https://dplyr.tidyverse.org/reference/rename.html) | cambiar el nombre de las columnas | **dplyr**  
clean_names() | estandarizar la sintaxis de los nombres de las columnas | **janitor** 
[as.character()](https://rdrr.io/r/base/character.html), [as.numeric()](https://rdrr.io/r/base/numeric.html), [as.Date()](https://rdrr.io/r/base/as.Date.html), etc. | convertir el tipo de una columna | R **base**
across() | transformar varias columnas a la vez | **dplyr**   
funciones **tidyselect** | utilizar la lógica para seleccionar las columnas | **tidyselect**
[filter()](https://dplyr.tidyverse.org/reference/filter.html) | mantener ciertas filas | **dplyr**  
[distinct()](https://dplyr.tidyverse.org/reference/distinct.html) | de-duplicar filas | **dplyr**  
rowwise() | operaciones por/en cada fila | **dplyr**   
add_row() | añadir filas manualmente | **tiblle**   
[arrange()](https://dplyr.tidyverse.org/reference/arrange.html) | ordenar las filas | **dplyr**   
recode() |recodificar los valores de una columna | **dplyr**   
case_when() | recodificar los valores de una columna con criterios lógicos más complejos | **dplyr**   
replace_na(), na_if(), coalesce() | funciones especiales de recodificación | **tidyr**   
age_categories() y [cut()](https://rdrr.io/r/base/cut.html) | crear grupos categóricos a partir de una columna numérica | **epikit** y R **base**
clean_variable_spelling() | recodificación/limpieza de valores mediante un diccionario de datos | **lista de líneas**   
[which()](https://rdrr.io/r/base/which.html) | aplicar los criterios lógicos; devolver los índices | R **base**

Si quieres ver cómo se comparan estas funciones con los comandos de Stata o SAS, consulta la página sobre la [transición a R](#transition-to-r). 

Puedes encontrar una gestión de datos alternativa en el paquete R **data.table** con operadores como `:=` y el uso frecuente de corchetes `[ ]`. Este enfoque y la sintaxis se explican brevemente en la página [Data.Table](https://epirhandbook.com/data-table.html#data-table). 

### Nomenclatura {.unnumbered} 

En este manual, generalmente hacemos referencia a "columnas" y "filas" en lugar de "variables" y "observaciones". Como se explica en este manual sobre ["datos ordenados"](https://tidyr.tidyverse.org/articles/tidy-data.html), la mayoría de los conjuntos de datos estadísticos epidemiológicos se componen estructuralmente de filas, columnas y valores. 

Las *variables* contienen los valores que miden el mismo atributo subyacente (como el grupo de edad, el resultado o la fecha de inicio). Las *observaciones* contienen todos los valores medidos en la misma unidad (por ejemplo, una persona, un lugar o una muestra de laboratorio). Por lo tanto, estos aspectos pueden ser más difíciles de definir de forma tangible. 

En los conjuntos de datos "ordenados", cada columna es una variable, cada fila es una observación y cada celda es un único valor. Sin embargo, algunos conjuntos de datos que se encuentran no se ajustan a este molde: unos datos de formato "amplio" pueden tener una variable dividida en varias columnas (véase un ejemplo en la página [Pivotar datos](#pivoting-data)). Del mismo modo, las observaciones pueden estar divididas en varias filas. 

La mayor parte de este manual trata sobre la gestión y la transformación de datos, por lo que las referencias a las estructuras de datos concretas de filas y columnas son más relevantes que las observaciones y las variables más abstractas. Las excepciones se dan sobre todo en las páginas sobre análisis de datos, en las que verás más referencias a las variables y las observaciones. 

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Limpieza de tuberías 

**Esta página recorre los pasos típicos de limpieza, añadiéndolos secuencialmente a una cadena de tuberías de limpieza.** 

En el análisis epidemiológico y el procesamiento de datos, los pasos de limpieza se realizan a menudo de forma secuencial, enlazados entre sí. En R, esto se manifiesta a menudo como una "tubería" de limpieza, en la que *los datos en bruto se pasan o se "canalizan" de un paso de limpieza a otro*. 

Estas cadenas utilizan las funciones de **dplyr** y el operador `%>%` de **magrittr**. Esta tubería comienza con los datos "en bruto" ("linelist_raw.xlsx") y termina con un dataframe de R "limpio" (`linelist`) que se puede utilizar, guardar, exportar, etc. 

En un proceso de limpieza, el orden de los pasos es importante. Los pasos de limpieza pueden incluir: 

* Importación de datos 
* Limpieza o cambio de los nombres de las columnas 
* de-duplicación 
* Creación y transformación de columnas (por ejemplo, recodificación o normalización de valores) 

* Filtrado o añadido de filas 


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Carga de paquetes 

Este trozo de código muestra la carga de los paquetes necesarios para el análisis. En este manual destacamos `p_load()` de **pacman**, que instala el paquete si es necesario *y* lo carga para su uso. También puedes cargar los paquetes instalados con `library()` de R **base.** Consulta la página sobre [Aspectos generales de R](#r-basics) para obtener más información sobre los paquetes de R. 

```{r, message = F}
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse   # data management and visualization
)
```


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Importar datos 

### Importar {.unnumbered} 

Aquí importamos el archivo Excel de la lista de casos "en bruto" utilizando la función `import()` del paquete **rio**. El paquete **rio** maneja con flexibilidad muchos tipos de archivos (por ejemplo, .xlsx, .csv, .tsv, .rds. Consulta la página sobre [importación y exportación](#import-and-export) para obtener más información y consejos sobre situaciones inusuales (por ejemplo, omitir filas, establecer valores que faltan, importar hojas de Google, etc). 

Para continuar, [cliquea para descargar linelist "en crudo"](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx) (como archivo .xlsx). 

Si tu conjunto de datos es grande y tarda mucho en importarse, puede ser útil que el comando de importación esté separado de la cadena de tuberías y que el "crudo" se guarde como un archivo distinto. Esto también permite comparar fácilmente las versiones original y limpia. 

A continuación, importamos el archivo de Excel sin procesar y lo guardamos como el dataframe `linelist_raw`. Suponemos que el archivo se encuentra en tu directorio de trabajo o en la raíz del proyecto R, por lo que no se especifican subcarpetas en la ruta del archivo. 


```{r, echo=F, message=F}
# HIDDEN FROM READER
# actually load the data using here()
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Puedes ver las primeras 50 filas del dataframe a continuación. Nota: la función **base** de R `head(n)` te permite ver sólo las primeras n filas en la consola de R. 

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


## Revisar {.unnumbered}  

Puedes utilizar la función `skim()` del paquete **skimr** para obtener una visión general de todo el dataframe (véase la página sobre [tablas descriptivas](#descriptive-tables) para más información). Las columnas se resumen por clase o tipo, como, por ejemplo, carácter, numérico. Nota: "POSIXct" es un tipo de fecha cruda (ver [Trabajar con fechas](#working-with-dates-1). 

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Nombres de columnas {}

En R, los *nombres* de las columnas son la "cabecera" o el valor "superior" de una columna. Se utilizan para referirse a las columnas en el código, y sirven como etiqueta por defecto en las figuras. 

Otros programas estadísticos, como SAS y STATA, utilizan *"etiquetas"* que coexisten como versiones impresas más largas de los nombres de columna más cortos. Aunque R ofrece la posibilidad de añadir etiquetas de columna a los datos, no es una práctica que sea muy utilizada. Para hacer que los nombres de las columnas sean "fáciles de imprimir" para las figuras, normalmente se ajusta su visualización dentro de los comandos de gráficas que crean las salidas (por ejemplo, los títulos de los ejes o de las leyendas de una gráfica, o las cabeceras de las columnas en una tabla impresa - véase la [sección de escalas de la página de consejos de ggplot](#ggplot_tips_scales) y las páginas de [Tablas para la presentación](#tables-for-presentation)). Si deseas asignar etiquetas de columna en los datos, lee más online [aquí](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) y [aquí](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html). 

Como los nombres de las columnas de R se utilizan con mucha frecuencia, deben tener una sintaxis "limpia". Sugerimos lo siguiente: 

* Nombres cortos 
* Sin espacios (sustituir por barras bajas _ ) 
* Sin caracteres inusuales (&, #, <, >, ...) 
* Nomenclatura de estilo similar (por ejemplo, todas las columnas de fecha nombradas como **date**_onset, **date**_report, **date**_death...) 

Los nombres de las columnas de `linelist_raw` se muestran a continuación utilizando `names()` de R **base**. Podemos ver que inicialmente 

* Algunos nombres contienen espacios (por ejemplo, `infection date`) 

* Se utilizan diferentes patrones de nomenclatura para las fechas (`date onset` vs. `infection date`) 

* Debe haber habido una *cabecera fusionada* en las dos últimas columnas del .xlsx. Lo sabemos porque el nombre de dos columnas fusionadas ("merged_header") fue asignado por R a la primera columna, y a la segunda columna se le asignó un nombre de marcador de posición "...28" (ya que entonces estaba vacía y es la columna 28). 

```{r}
names(linelist_raw)
```

<span style="color: black;">***NOTA:*** Para hacer referencia a un nombre de columna que incluya espacios, rodee el nombre con tildes, por ejemplo: linelist``$\` '\x60infection date\x60' ``. Ten en cuenta que, en tu teclado, la tilde (\`) es diferente de la comilla simple ('). </span>

### Etiquetas {.unnumbered}  

Algunos otros programas estadísticos, como SAS, tienen *etiquetas* de variables 

### Limpieza automática {.unnumbered}  

La función `clean_names()` del paquete **janitor** estandariza los nombres de las columnas y los hace únicos haciendo lo siguiente: 

* Convierte todos los nombres para que estén compuestos sólo por barras bajas, números y letras 
* Los caracteres acentuados se transliteran a ASCII (por ejemplo, la o alemana con diéresis se convierte en "o", la "ñ" española se convierte en "n") 
* Se puede especificar la preferencia de mayúsculas para los nuevos nombres de columna utilizando `case =` argumento ("snake" es el valor por defecto, las alternativas incluyen "sentence", "title", "small_camel"...) 
* Puedes especificar sustituciones de nombres concretos proporcionando un vector `replace =` argumento (por ejemplo, `replace = c(onset = "date_of_onset")`)

* Aquí puedes encontrar una  [viñeta](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) en línea sobre dicho paquete. 

A continuación, el proceso de limpieza comienza utilizando `clean_names()` sobre linelist_raw. 

```{r clean_names}
# pipe the raw dataset through the function clean_names(), assign result as "linelist"  
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new column names
names(linelist)
```

<span style="color: black;">***NOTA:*** El nombre de la última columna "...28" se ha cambiado por "x28". </span>

### Limpieza manual de nombres {.unnumbered}  

A menudo es necesario renombrar las columnas manualmente, incluso después del paso de estandarización anterior. A continuación, el renombramiento se realiza utilizando la función `rename()` del paquete **dplyr**, como parte de una cadena de tuberías. `rename()` utiliza el estilo `NUEVO = ANTIGUO` - el nombre nuevo de la columna se escribe antes que el antiguo. 

A continuación, se añade un comando de renombramiento a la tubería de limpieza. Se han añadido espacios estratégicamente para alinear el código y facilitar la lectura. 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```


Ahora puedes ver que los nombres de las columnas han cambiado: 

```{r message=FALSE, echo=F}
names(linelist)
```

#### Renombrar por posición de columna {.unnumbered} 

También puedes renombrar por la posición de la columna, en lugar del nombre de la columna, por ejemplo: 

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### Renombrar mediante `select()` y `summarise()` {.unnumbered}

Como método abreviado, también puedes cambiar el nombre de las columnas dentro de las funciones de **dplyr** `select()` y `summarise()`. `select()` se utiliza para mantener sólo ciertas columnas (y se muestra más adelante en esta página). `summarise()` se muestra en las páginas [Agrupar datos](#grouping-data) y [Tablas descriptivas](#descriptive-tables). Estas funciones también utilizan el formato `nombre_nuevo = nombre_antiguo`. He aquí un ejemplo: 

```{r, eval=F}
linelist_raw %>% 
  select(# NEW name             # OLD name
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns
         date_hospitalisation = `hosp date`)
```

### Otros retos {.unnumbered} 

#### Nombres de columnas de Excel vacíos {.unnumbered} 

R no puede tener columnas de conjuntos de datos que no tengan nombres de columnas (cabeceras). Así, si importa unos datos de Excel con datos pero sin cabeceras de columna, R rellenará las cabeceras con nombres como "...1" o "...2". El nombre asignado representa el número de la columna (por ejemplo, si la cuarta columna de los datos no tiene cabecera, R la nombrará "...4"). 

Puedes limpiar estos nombres manualmente haciendo referencia a su número de posición (véase el ejemplo anterior), o a su nombre asignado (`linelist_raw$...1`). 

#### Nombres de columnas y celdas fusionadas de Excel {.unnumbered}

Las celdas combinadas en un archivo de Excel son una ocurrencia común cuando se reciben datos. Como se explica en [Transición a R](#transition-to-r), las celdas combinadas pueden ser agradables para la lectura humana de los datos, pero no son "datos ordenados" y causan muchos problemas para la lectura de los datos por parte de las máquinas. R no puede ajustar las celdas combinadas. 

Recuerda a las personas que introducen los datos que **los datos legibles para el ser humano no son lo mismo que los datos legibles para la máquina**. Esfuérzate en formar a los usuarios sobre los principios de los [[**datos ordenados**](https://r4ds.had.co.nz/tidy-data.html). Si es posible, intenta cambiar los procedimientos para que los datos lleguen en un formato ordenado y sin celdas fusionadas. 

* Cada variable debe tener su propia columna. 
* Cada observación debe tener su propia fila. 
* Cada valor debe tener su propia celda. 

Al utilizar la función `import()` de **rio**, el valor de una celda combinada se asignará a la primera celda y las siguientes estarán vacías. 

Una solución para tratar las celdas combinadas es importar los datos con la función `readWorkbook()` del paquete **openxlsx**. Establece el argumento `fillMergedCells = TRUE`. Esto da el valor en una celda fusionada a todas las celdas dentro del rango de fusión. 

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

<span style="color: red;">***PELIGRO:*** Si los nombres de las columnas se fusionan con `readWorkbook()`, terminarás con nombres de columnas duplicados, que tendrás que arreglar manualmente - ¡R no funciona bien con nombres de columnas duplicados! Puedes renombrarlas haciendo referencia a su posición (por ejemplo, la columna 5), como se explica en la sección de limpieza manual de nombres de columnas. </span>




 

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Seleccionar o reordenar columnas {} 

Utiliza `select()` de **dplyr** para seleccionar las columnas que deseas conservar y para especificar su orden en el dataframe. 

<span style="color: orange;">***ATENCIÓN:*** En los ejemplos siguientes, el dataframe `linelist` se modifica con `select()` y se muestra, pero no se guarda. Esto es a efectos de demostración. Los nombres de las columnas modificadas se imprimen pasando el dataframe a `names()`.</span>

**Aquí están TODOS los nombres de las columnas en linelist en este punto de la cadena de limpieza:** 

```{r}
names(linelist)
```

### Mantener las columnas {.unnumbered}  

**Selecciona sólo las columnas que desees conservar** 

Escribe sus nombres en el comando `select()`, sin comillas. Aparecerán en el dataframe en el orden que indiques. Ten en cuenta que si incluyes una columna que no existe, R devolverá un error (véase el uso de `any_of()` más adelante para evitar un error de este tipo). 

```{r}
# linelist dataset is piped through select() command, and names() prints just the column names
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # display the column names
```



### Funciones de ayuda "tidyselect". 

Estas funciones de ayuda existen para facilitar la especificación de las columnas a conservar, descartar o transformar. Provienen del paquete **tidyselect**, que se incluye en **tidyverse** y se basa en la forma en que se seleccionan las columnas en las funciones de **dplyr**. 

Por ejemplo, si deseas reordenar las columnas, `everything()` es una función útil para indicar "todas las demás columnas no mencionadas". El comando siguiente mueve las columnas `date_onset` y `date_hospitalisation` al principio (izquierda) de los datos, pero mantiene todas las demás columnas después. Fíjate en que `everything()` se escribe con paréntesis vacíos: 

```{r}
# move date_onset and date_hospitalisation to beginning
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Aquí hay otras funciones de ayuda "tidyselect" que también funcionan *dentro de* las funciones de **dplyr** como `select()`, `across()` y `summarise()`: 

* `everything()` - todas las demás columnas no mencionadas 

* `last_col()` - la última columna 

* `where()` - aplica una función a todas las columnas y selecciona las que son TRUE 

* `contains()` - columnas que contienen una cadena de caracteres  * ejemplo: `select(contains("time"))`

* `starts_with()` - coincide con un prefijo especificado  * ejemplo: `select(starts_with("date_"))`

* `ends_with()` - coincide con un sufijo especificado  * ejemplo: `select(ends_with("_post))` 

* `matches()` - para aplicar una expresión regular (regex)  * ejemplo: `select(matches("[pt]al"))` 

* `num_range()` - un rango numérico como x01, x02, x03 

* `any_of()` - coincide con la columna SI existe pero no devuelve ningún error si no se encuentra  * ejemplo: `select(any_of(date_onset, date_death,     cardiac_arrest)) `

Además, utiliza operadores normales como `c()` para listar varias columnas, `:` para columnas consecutivas, `!` para opuestas, `&` para "Y" y `|` para "O". 

Utiliza `where()` para especificar criterios lógicos para las columnas. Si escribes una función dentro de `where()`, no incluyas los paréntesis vacíos de la función. El comando siguiente selecciona las columnas de tipo Numeric. 

```{r}
# select columns that are class Numeric
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Utiliza `contains()` para seleccionar sólo las columnas en las que el nombre de la columna contiene una cadena de caracteres especificada. `ends_with()` y `starts_with()` proporcionan más matices. 

```{r}
# select columns containing certain characters
linelist %>% 
  select(contains("date")) %>% 
  names()
```

La función `matches()` funciona de forma similar a `contains()`, pero puede escribirse en una expresión regular (mira la página sobre [Caracteres y cadenas](#characters-and-strings)), como varias cadenas separadas por barras "O" dentro de los paréntesis: 

```{r}
# searched for multiple character matches
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

<span style="color: orange;">***ATENCIÓN:*** Si has escrito un nombre de columna y no existen datos para ella, puede devolver un error y detener tu código. Considera el uso de `any_of()` para citar columnas que pueden o no existir, especialmente útil en selecciones negativas (eliminar). </span>

Sólo existe una de estas columnas, pero no se produce ningún error y el código continúa sin detener su cadena de limpieza. 

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Eliminar columnas {.unnumbered} 

**Indica qué columnas se van a eliminar** colocando el símbolo "-" delante del nombre de la columna (por ejemplo, select(-outcome)), o un vector de nombres de columnas (como se indica a continuación). Todas las demás columnas se mantendrán. 

También puedes eliminar una columna utilizando la sintaxis de R **base**, definiéndola como NULL. Por ejemplo: 

Independiente 

select() también puede utilizarse como un comando independiente (no en una cadena de tuberías). En este caso, el primer argumento es el dataframe original sobre el que se va a operar. 

Añadir a la cadena de tuberías 

En linelist_raw, hay algunas columnas que no necesitamos: row_num, merged_header y x28. Las eliminamos con un comando select() en la cadena de tuberías de limpieza: 

Deduplicación 

Consulta la página sobre [de-duplicación](#de-duplication) para ver la cantidad de opciones sobre cómo eliminar las duplicidades (deduplicar). Aquí sólo se presenta un ejemplo muy sencillo de deduplicación de filas. 

El paquete **dplyr** ofrece la función distinct(). Esta función examina cada fila y reduce el dataframe con sólo filas únicas. Es decir, elimina las filas que están 100% duplicadas. 

Al evaluar las filas duplicadas, tiene en cuenta un rango de columnas - por defecto considera todas las columnas. Como se muestra en la página de deduplicación, puedes ajustar este rango de columnas para que la singularidad de las filas sólo se evalúe con respecto a determinadas columnas. 

En este sencillo ejemplo, simplemente añadimos el comando vacío distinct() a la cadena de tuberías. Esto garantiza que no haya filas que estén 100% duplicadas de otras filas (evaluadas en todas las columnas). 

Comenzamos con nrow(linelist) filas en linelist. 

Después de la deduplicación hay nrow(linelist) filas. Las filas eliminadas habrían sido 100% duplicados de otras filas. 

A continuación, se añade el comando distinct() a la cadena de tuberías de limpieza: 

Creación y transformación de columnas 

**Recomendamos utilizar la función dplyr mutate() para añadir una nueva columna, o para modificar una existente.** 

A continuación se muestra un ejemplo de creación de una nueva columna con mutate(). La sintaxis es: mutate(nombre_nueva_columna = valor o transformación) 

En Stata, esto es similar al comando generate, pero también se puede utilizar mutate() de R para modificar una columna existente. 

Nuevas columnas 

El comando más básico de mutate() para crear una nueva columna podría tener este aspecto. Crea una nueva columna new_col donde el valor en cada fila es 10. 

También puedes referenciar valores en otras columnas, para realizar cálculos. A continuación, se crea una nueva columna bmi para mantener el Índice de Masa Corporal (BMI) de cada caso - calculado mediante la fórmula BMI = kg/m\^2, utilizando la columnas ht_cm y wt_kg. 

Si creas varias columnas nuevas, separa cada una con una coma y una nueva línea. A continuación se muestran ejemplos de nuevas columnas, incluidas las que consisten en valores de otras columnas combinadas mediante str_glue() del paquete **stringr** (véase la página sobre [Caracteres y cadenas](#characters-and-strings). 

Revisa las nuevas columnas. A efectos de demostración, sólo se muestran las nuevas columnas y las columnas utilizadas para crearlas: 

***CONSEJO:*** Una variación de mutate() es la función transmute(). Esta función añade una nueva columna al igual que mutate(), pero también elimina todas las demás columnas que no se mencionan dentro de sus paréntesis. 

Convertir el tipo de columna 

Las columnas que contienen valores que son fechas, números o valores lógicos (TRUE/FALSE) sólo se comportarán como se espera si están correctamente clasificadas. Hay una diferencia entre "2" de tipo carácter y 2 de tipo numérico! 

Hay formas de establecer el tipo de la columna durante los comandos de importación, pero esto suele ser engorroso. Consulta la sección [Aspectos básicos de R](#r-basics) sobre los tipos de objeto para saber más sobre la conversión de los tipos de objetos y columnas. 

En primer lugar, vamos a realizar algunas comprobaciones en las columnas importantes para ver si son del tipo correcto. También vimos esto al principio cuando ejecutamos skim(). 

Actualmente, el tipo de la columna de edad es un carácter. Para realizar análisis cuantitativos, necesitamos que estos números sean reconocidos como numéricos. 

El tipo de la columna date_onset ¡también es un carácter! Para realizar los análisis, ¡estas fechas deben ser reconocidas como fechas! 

Para resolver esto, utiliza la capacidad de mutate() para redefinir una columna mediante una transformación. Definimos la columna como ella misma, pero convertida a un tipo diferente. He aquí un ejemplo básico, convirtiendo o asegurando que la columna edad es de tipo Numeric: 

De forma similar, puedes utilizar as.character() y as.logical(). Para convertir al tipo Factor, puedes utilizar factor() de R **base** o as_factor() de **forcats**. Lee más sobre esto en la página de [Factores](#factors). 

Hay que tener cuidado al convertir al tipo Fecha. En la página [Trabajar con fechas](#working-with-dates-1) se explican varios métodos. Normalmente, los valores de fecha en el fichero crudo deben estar todos en el mismo formato para que la conversión funcione correctamente (por ejemplo, "MM/DD/AAAA", o "DD MM AAAA"). Después de convertir al tipo Fecha, comprueba tus datos para confirmar que cada valor se ha convertido correctamente. 

Datos agrupados 

Si tu dataframe ya está *agrupado* (véase la página sobre [Agrupar datos](#grouping-data)), mutate() puede comportarse de forma diferente que si el dataframe no está agrupado. Cualquier función de resumen, como mean(), median(), max(), etc. calculará con datos agrupados, no con filas de registros individualizados. 

Lee más sobre el uso de mutate () sobre dataframes agrupados en esta [documentación de tidyverse mutate](https://dplyr.tidyverse.org/reference/mutate.html). 

Transformar múltiples columnas 

A menudo, para escribir un código conciso, se desea aplicar la misma transformación a varias columnas a la vez. Se puede aplicar una transformación a varias columnas a la vez utilizando la función across() del paquete **dplyr** (también contenido en el paquete **tidyverse**). across() se puede utilizar con cualquier función **de dplyr**, pero se suele utilizar dentro de select(), mutate(), filter() o summarise(). Mira cómo se aplica a summarise() en la página sobre [Tablas descriptivas](#descriptive-tables). 

Especificar los argumentos de las columnas .cols = y la(s) función(es) a aplicar a .fns =. Cualquier argumento adicional a la función .fns puede incluirse después de una coma, todavía dentro de across(). 

selección de columnas across() 

Especificar las columnas de .cols =. Puedes nombrarlas individualmente, o utilizar funciones de ayuda "tidyselect". Especifica la función en .fns =. Ten en cuenta que, utilizando el modo de función mostrado a continuación, la función se escribe *sin* sus paréntesis (). 

Aquí la transformación as.character() se aplica a columnas específicas nombradas dentro de across(). 

Las funciones de ayuda "tidyselect" están disponibles para ayudarle a especificar las columnas. Se detallan más arriba en la sección sobre Selección y reordenación de columnas, e incluyen: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() y any_of(). 

Este es un ejemplo de cómo se pueden cambiar **todas las columnas** al tipo carácter: 

Convertir en caracteres todas las columnas cuyo nombre contenga la cadena "fecha" (fíjate en la colocación de comas y paréntesis): 

A continuación, un ejemplo de mutación de las columnas que actualmente son de tipo POSIXct (un tipo datetime cruda que muestra etiquetas) - en otras palabras, donde la función is.POSIXct() evalúa a TRUE. Entonces queremos convertirlas con la función as.Date() en columnas de tipo Date normal. 

* Ten en cuenta que dentro de across() también utilizamos la función where() como is.POSIXct está evaluando a TRUE o FALSE. 

* Ten en cuenta que is.POSIXct() es del paquete **lubridate**. Otras funciones "is" similares como is.character(), is.numeric(), e is.logical() son de R **base** 

funciones across() 

Puedes leer la documentación de ayuda con detalles sobre cómo proporcionar funciones a across() escribiendo ?across: hay varias formas de especificar la(s) función(es) a realizar en una columna e incluso puedes definir tus propias funciones: 

* Puedes escribir el nombre de la función sola (por ejemplo, media o as.carácter) 

* Puedes escribir la función en **estilo purrr (por** ejemplo, \~ mean(.x, na.rm = TRUE)) (mira [esta página](#iteration-loops-and-lists)) 

* Puedes especificar varias funciones escribiendo una lista (por ejemplo, list(media = media, n_miss = \~ suma(is.na(.x))).  * Si proporcionas varias funciones, se devolverán varias columnas     transformadas por cada columna de entrada, con nombres únicos     con formato col_fn. Puedes ajustar cómo se nombran las columnas     nuevas con el argumento .names = utilizando la sintaxis **glue**     (mira la página sobre [Caracteres y     cadenas](#characters-and-strings)) donde {.col} y     {.fn} son la abreviatura de la columna de entrada y la función. 

Aquí hay algunos recursos en línea sobre el uso de across(): [pensamientos/razones del creador Hadley Wickham](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/) 

coalesce() 

Esta función de **dplyr** encuentra el primer valor no missing en cada posición. Rellena los valores que faltan con el primer valor disponible en el orden que especifiques. 

Aquí hay un ejemplo *fuera del contexto de un dataframe*: Supongamos que tienes dos vectores, uno que contiene el pueblo de detección del paciente y otro que contiene el pueblo de residencia del paciente. Puedes utilizar coalesce para elegir el primer valor no ausente de cada índice: 

Esto funciona de la misma manera si se proporcionan columnas del dataframe: para cada fila, la función asignará el nuevo valor de la columna con el primer valor que no falte en las columnas proporcionadas (en el orden indicado). 

Este es un ejemplo de operación "por filas". Para cálculos más complicados por filas, consulta la sección siguiente sobre cálculos por filas. 

Matemáticas acumulativas 

Si deseas que una columna refleje la suma/media/min/máxima, etc. acumulada, tal y como se ha evaluado en las filas de un dataframe hasta ese punto, utiliza las siguientes funciones: 

cumsum() devuelve la suma acumulada, como se muestra a continuación: 

Esto se puede utilizar en un dataframe al crear una nueva columna. Por ejemplo, para calcular el número acumulado de casos por día en un brote, considere un código como este: 

A continuación se muestran las 10 primeras filas: 

Consulta la página sobre [curvas epidémicas](#epidemic-curves) para saber cómo representar la incidencia acumulada con epicurve. 

Véase también:\ cumsum(), cummean(), cummin(), cummax(), cumany(), cumall() 

Utilizando R **base** 

Para definir una nueva columna (o redefinir una columna) utilizando R **base**, escribe el nombre del dataframe, conectado con $, a la *nueva* columna (o la columna a modificar). Utiliza el operador de asignación <- para definir el nuevo valor o valores. Recuerda que al usar R **base** debes especificar siempre el nombre del dataframe antes del nombre de la columna (por ejemplo, dataframe$columna). Este es un ejemplo de creación de la columna bmi usando R **base**: 

Añadir tuberías a la cadena 

**A continuación, se añade una nueva columna a la cadena de tuberías y se convierten algunos tipos.** 

Recodificar valores 

A continuación, se presentan algunos escenarios en los que es necesario recodificar (cambiar) los valores: 

* para editar un valor específico (por ejemplo, una fecha con un año o formato incorrecto) 

* para conciliar valores que no se escriben igual 

* para crear una nueva columna de valores categóricos 

* para crear una nueva columna de categorías numéricas (por ejemplo, categorías de edad) 

Valores específicos 

Para cambiar los valores manualmente puedes utilizar la función recode() dentro de la función mutate(). 

Imagínate que hay una fecha sin sentido en los datos (por ejemplo, "2014-14-15"): podrías corregir la fecha manualmente en los datos originales, o bien, podrías escribir el cambio en la serie de comandos de limpieza a través de mutate() y recode(). Esto último es más transparente y reproducible para cualquier otra persona que quiera entender o repetir su análisis. 

La línea mutate() anterior puede leerse como: "mutar la columna date_onset para que sea igual a la columna date_onset recodificada de forma que el VALOR ANTIGUO se cambie por el NUEVO VALOR". Ten en cuenta que este patrón (VIEJO = NUEVO) para recodificar() es el opuesto a la mayoría de los patrones de R (nuevo = viejo). La comunidad de desarrollo de R está trabajando en la revisión de esto. 

**Aquí hay otro ejemplo de recodificación de múltiples valores dentro de una columna.** 

En linelist hay que limpiar los valores de la columna "hospital". Hay varias grafías diferentes y muchos valores que faltan. 

El comando recode() de abajo redefine la columna "hospital" como la columna actual "hospital", pero con los cambios especificados en la recodificación. ¡No olvides las comas después de cada uno! 

Ahora vemos que se han corregido y consolidado las grafías de la columna hospital: 

***CONSEJO:*** El número de espacios antes y después de un signo de igualdad no importa. Haz que tu código sea más fácil de leer alineando el signo = para todas o la mayoría de las filas. Además, considera la posibilidad de añadir una fila de comentarios con hash (#) para aclarar a los futuros lectores qué lado es VIEJO y qué lado es NUEVO. 

***CONSEJO:*** A veces existe un valor con caracteres *en blanco* en unos datos (no reconocido como valor Missing - Na de R. Puedes hacer referencia a este valor con dos comillas sin espacio intermedio (""). 

Por lógica 

A continuación, demostramos cómo recodificar los valores de una columna utilizando lógica y condiciones: 

* Uso de replace(), ifelse() e if_else() para una lógica simple 

* Uso de case_when() para una lógica más compleja 

Lógica simple 

replace() 

Para recodificar con criterios lógicos simples, puedes utilizar replace() dentro de mutate(). replace() es una función de R **base**. Utiliza una condición lógica para especificar las filas a cambiar . La sintaxis general es: 

mutate(col_to_change = replace(col_to_change, criterio para filas, nuevo valor)). 

Una situación común para utilizar replace() es **cambiar sólo un valor en una fila, utilizando un identificador de fila único**. A continuación, el género se cambia a "Mujer" en la fila donde la columna case_id es "2195". 

El comando equivalente utilizando la sintaxis de R **base** y los paréntesis de indexación [ ] está abajo. Se lee como "Cambia el valor de la columna género del dataframe linelist a 'Mujer'" (para las filas en las que la columna case_id del listado tiene el valor '2195'). 

ifelse() y if_else() 

Otra herramienta para la lógica simple es ifelse() y su compañero if_else(). Sin embargo, en la mayoría de los casos para la recodificación es más claro utilizar case_when() (detallado a continuación). Estos comandos "if else" son versiones simplificadas de una sentencia de programación if y else. La sintaxis general es: 

ifelse(condición, valor a devolver si la condición evalúa como TRUE, valor a devolver si la condición evalúa como FALSE) 

A continuación, se define la columna fuente_conocida. Su valor en una fila determinada se establece como "conocido" si *no falta* el valor de la fila en la columna fuente. *Si falta* el valor de la fuente, el valor de source_known se establece como "desconocido". 

if_else() es una versión especial de **dplyr** que maneja fechas. Ten en cuenta que, si el valor "verdadero" es una fecha, el valor "falso" también debe calificar una fecha, de ahí que se utilice el valor especial NA_real_ en lugar de simplemente NA. 

**Evite encadenar muchos comandos ifelse... ¡utilice** case_when**() en su lugar!** case_when() es mucho más fácil de leer y cometerá menos errores. 

Fuera del contexto de un dataframe, si deseas que un objeto utilizado en su código cambie su valor, considere el uso de switch() de R **base**. 

Lógica compleja 

Utiliza case_when() de **dplyr** si estás recodificando en muchos grupos nuevos, o si necesita utilizar sentencias lógicas complejas para recodificar valores. Esta función evalúa si cada fila del dataframe cumple los criterios especificados y asigna el nuevo valor correcto. 

Los comandos case_when() consisten en sentencias que tienen un lado derecho (RHS) y un lado izquierdo (LHS) separados por una "tilde" \~ (cola de chancho). Los criterios lógicos están en el lado izquierdo y los valores de conformidad están en el lado derecho de cada sentencia. Las declaraciones están separadas por comas. 

Por ejemplo, aquí utilizamos las columnas edad y edad_unidad para crear una columna edad_años: 

A medida que se evalúa cada fila de los datos, los criterios se aplican/evalúan en el orden en que se escriben las sentencias case_when(), de arriba a abajo. Si el criterio superior se evalúa como TRUE para una fila determinada, se asigna el valor RHS, y los criterios restantes ni siquiera se prueban para esa fila. Por lo tanto, es mejor escribir los criterios más específicos primero y los más generales al final. 

En esta línea, en su declaración final, coloque TRUE en el lado izquierdo, lo que capturará cualquier fila que no cumpla ninguno de los criterios anteriores. Al lado derecho de esta declaración se le podría asignar un valor como "¡comprobado!" o faltante. 

***PELIGRO:* Los valores del lado derecho deben ser todos del mismo tipo**: numéricos, de caracteres, de fecha, lógicos, etc. Para asignar faltantes (NA), puede ser necesario utilizar variaciones especiales de NA como NA_character_, NA_real_ (para numérico o POSIX), y as.Date(NA). Lea más en [Trabajar con fechas](#working-with-dates-1). 

Valores faltantes 

A continuación, se presentan funciones especiales para el tratamiento de los valores faltantes en el contexto de la limpieza de datos. 

Consulta la página sobre [Valores faltantes](#missing-data) para obtener consejos más detallados sobre la identificación y el tratamiento de los valores faltantes. Por ejemplo, la función is.na() que comprueba lógicamente la ausencia de datos. 

**replace_na()** 

Para cambiar los valores faltantes (NA) por un valor específico, como "Missing", utilice la función **dplyr** replace_na() dentro de mutate(). Ten en cuenta que se utiliza de la misma manera que recodificar anteriormente - el nombre de la variable debe repetirse dentro de replace_na(). 

**fct_explicit_na()** 

Esta es una función del paquete **forcats**. El paquete **forcats** maneja columnas del tipo Factor. Los factores son la forma en que R maneja valores *ordenados* como c("Primero", "Segundo", "Tercero") o para establecer el orden en que los valores (por ejemplo, hospitales) aparecen en las tablas y gráficos. Vea la página sobre [Factores](#factors). 

Si tus datos son del tipo Factor y tratas de convertir NA en "Missing" utilizando replace_na(), obtendrás este error: nivel de factor no válido, NA generado. Ha intentado añadir "Missing" como valor, cuando no estaba definido como un posible nivel del factor, y ha sido rechazado. 

La forma más fácil de resolver esto es utilizar la función **forcats** fct_explicit_na() que convierte una columna en factor de tipo, y convierte los valores NA en el carácter "(Missing)". 

Una alternativa más lenta sería añadir el nivel del factor utilizando fct_expand() y luego convertir los valores que faltan. 

**na_if()** 

Para convertir un *valor específico en* NA, utilice na_if() de **dplyr**. El comando siguiente realiza la operación opuesta a replace_na(). En el siguiente ejemplo, cualquier valor de "Missing" en la columna hospital se convierte en NA. 

Nota: na_if() **no puede utilizarse para criterios lógicos** (por ejemplo, "todos los valores > 99") - utilice replace() o case_when() para ello: 

Diccionario de limpieza 

Utilice el paquete R **linelist** y su función clean_variable_spelling() para limpiar un dataframe con un *diccionario de limpieza*. **linelist** es un paquete desarrollado por [RECON](https://github.com/reconhub/linelist) - el Consorcio R Epidemics. 

1.  Crear un diccionario de limpieza con 3 columnas:  * Una columna "desde" (el valor incorrecto)  * Una columna "para" (el valor correcto)  * Una columna que especifica la columna a la que se aplicarán los     cambios (o ".global" para aplicarlo a todas las columnas) 

Nota: Las entradas del diccionario global serán anuladas por las entradas del diccionario específico de la columna. 

2.  Importe el archivo del diccionario a R. Este ejemplo puede descargarse a través de las instrucciones de la página [Descargar manual y datos](#download-handbook-and-data). 

3.  Pase linelist crudas a clean_variable_spelling(), especificando a wordlists = el dataframe del diccionario de limpieza. El argumento spelling_vars = puede utilizarse para especificar a qué columna del diccionario se refieren las columnas (la tercera por defecto), o puede establecerse como NULL para que el diccionario se aplique a todas las columnas de caracteres y factores. Ten en cuenta que esta función puede tardar mucho en ejecutarse. 

Ahora desplácese a la derecha para ver cómo han cambiado los valores - en particular el género (de minúsculas a mayúsculas), y todas las columnas de síntomas se han transformado de sí/no a 1/0. 

Ten en cuenta que los nombres de las columnas en el diccionario de limpieza deben corresponder a los nombres *en este punto* de su script de limpieza. Consulta esta [referencia en línea para el paquete linelist](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) para obtener más detalles. 

Añadir a la cadena de tuberías 

**A continuación, se añaden algunas columnas y transformaciones de columna nuevas a la cadena de tuberías.** 

Categorías numéricas 

Aquí describimos algunos enfoques especiales para crear categorías a partir de columnas numéricas. Algunos ejemplos comunes son las categorías de edad, los grupos de valores de laboratorio, etc. Aquí discutiremos: 

* age_categories(), del paquete **epikit** 

* cut(), de la **base** R 

* case_when() 

* ruptura de cuantiles con quantile() y ntile() 

Distribución de la revisión 

Para este ejemplo crearemos una columna age_cat utilizando la columna age_years. 

En primer lugar, examina la distribución de tus datos, para hacer los puntos de corte apropiados. Consulta la página sobre [los fundamentos de ggplot](#ggplot-basics). 

***ATENCIÓN:*** A veces, las variables numéricas se importarán como tipo "carácter". Esto ocurre si hay caracteres no numéricos en algunos de los valores, por ejemplo, una entrada de "2 meses" para la edad, o (dependiendo de la configuración de su configuración local de R) si se utiliza una coma en el lugar de los decimales (por ejemplo, "4,5" para significar cuatro años y medio). 

categorías_de_edad() 

Con el paquete **epikit**, puedes utilizar la función age_categories() para categorizar y etiquetar fácilmente las columnas numéricas (nota: esta función puede aplicarse también a las variables numéricas no relacionadas con la edad). Además, la columna de salida es automáticamente un factor ordenado. 

Aquí están las entradas requeridas: 

* Un vector numérico (columna) 

* El argumento breakers = - proporciona un vector numérico de puntos de ruptura para los nuevos grupos 

Primero, el ejemplo más sencillo: 

Los valores de ruptura que especificas son por defecto los límites inferiores - es decir, están incluidos en el grupo "superior" / los grupos están "abiertos" en la parte inferior/izquierda. Como se muestra a continuación, puedes añadir 1 a cada valor de ruptura para conseguir grupos que estén abiertos por la parte superior/derecha. 

Puedes ajustar cómo se muestran las etiquetas con el separador =. El valor predeterminado es "-" 

Puedes ajustar cómo se manejan los números superiores, con el argumento ceiling =. Para establecer un corte superior establezca ceiling = TRUE. En este uso, el valor de ruptura más alto proporcionado es un "techo" y no se crea una categoría "XX+". Cualquier valor por encima del valor de corte más alto (o hasta el límite superior =, si está definido) se categoriza como NA. A continuación, se muestra un ejemplo con techo = TRUE, de modo que no hay categoría de XX+ y los valores por encima de 70 (el valor de ruptura más alto) se asignan como NA. 

Alternativamente, en lugar de los interruptores =, puede proporcionar todos los inferiores =, superiores =, y por =: 

* lower = El número más bajo que se quiere considerar - por defecto es 0 

* upper = El número más alto que quiere que se considere 

* por = El número de años entre los grupos 

Consulta la página de ayuda de la función para obtener más detalles (introduzca ?age_categories en la consola de R). 

cortar() 

cut() es una alternativa **básica** de R a age_categories(), pero creo que verá por qué age_categories() se desarrolló para simplificar este proceso. Algunas diferencias notables de age_categories() son: 

* No es necesario instalar/cargar otro paquete 

* Puedes especificar si los grupos están abiertos/cerrados a la derecha/izquierda 

* Debes proporcionar etiquetas precisas 

* Si quieres que el 0 se incluya en el grupo más bajo debes especificar esto 

La sintaxis básica dentro de cut() es proporcionar primero la columna numérica que se va a cortar (edad_años), y luego el argumento *breaks*, que es un vector numérico c() de puntos de ruptura. Utilizando cut(), la columna resultante es un factor ordenado. 

Por defecto, la categorización se produce de manera que el lado derecho/superior es "abierto" e inclusivo (y el lado izquierdo/inferior es "cerrado" o exclusivo). Este es el comportamiento opuesto al de la función age_categories(). Las etiquetas por defecto utilizan la notación "(A, B]", lo que significa que A no está incluido pero B sí. **Invierta este comportamiento proporcionando el argumento right = TRUE**. 

Así, por defecto, los valores "0" se excluyen del grupo más bajo, y se categorizan como NA! Los valores "0" podrían ser codificados por los bebés como edad 0, así que ¡tenga cuidado! Para cambiar esto, añada el argumento include.lowest = TRUE para que cualquier valor "0" se incluya en el grupo más bajo. La etiqueta generada automáticamente para la categoría más baja será entonces "[A],B]". Ten en cuenta que si incluye el argumento include.lowest = TRUE **y** right = TRUE, la inclusión extrema se aplicará ahora al valor del punto de ruptura y a la categoría *más altos*, no a los más bajos. 

Puedes proporcionar un vector de etiquetas personalizadas utilizando el argumento labels =. Como se escriben manualmente, ¡ten mucho cuidado de que sean precisas! Comprueba el trabajo utilizando una tabulación cruzada, como se describe a continuación. 

A continuación se muestra un ejemplo de cut() aplicado a age_years para crear la nueva variable age_cat: 

**¡Comprueba tu trabajo!** Verifica que cada valor de edad fue asignado a la categoría correcta cruzando las columnas numéricas y de categoría. Examina la asignación de los valores límite (por ejemplo, 15, si las categorías vecinas son 10-15 y 16-20). 

**Re etiquetado de los valores NA** 

Puedes asignar a los valores NA una etiqueta como "Missing". Como la nueva columna es del tipo Factor (valores restringidos), no puedes simplemente mutarla con replace_na(), ya que este valor será rechazado. En su lugar, utilice fct_explicit_na() de **forcats** como se explica en la página de [Factores](#factors). 

**Realiza rápidamente pausas y etiquetas** 

Para una forma rápida de hacer rupturas y etiquetar vectores, utilice algo como lo siguiente. Consulta la página de [fundamentos de R](#r-basics) para obtener referencias sobre seq() y rep(). 

Lea más sobre cut() en su página de ayuda introduciendo ?cut en la consola de R. 

Roturas cuartílicas 

En el entendimiento común, los "cuartiles" o "percentiles" suelen referirse a un valor por debajo del cual cae una proporción de valores. Por ejemplo, el percentil 95 de las edades en linelist sería la edad por debajo de la cual cae el 95% de las edades. 

Sin embargo, en el lenguaje común, "cuartiles" y "deciles" también pueden referirse a los *grupos de datos* divididos por igual en 4 o 10 grupos (Ten en cuenta que habrá un punto de ruptura más que un grupo). 

Para obtener los puntos de ruptura de los cuartiles, se puede utilizar quantile() del paquete **stats** de R **base.** Se proporciona un vector numérico (por ejemplo, una columna en unos datos) y un vector de valores de probabilidad numérica que van de 0 a 1,0. Los puntos de ruptura se devuelven como un vector numérico. Explore los detalles de las metodologías estadísticas introduciendo ?quantile. 

* Si su vector numérico de entrada tiene valores faltantes, es mejor establecer na.rm = TRUE 

* Establecer nombres = FALSE para obtener un vector numérico sin nombre 

Puedes utilizar los resultados de quantile() como puntos de ruptura en age_categories() o cut(). A continuación creamos una nueva columna deciles utilizando cut() donde los puntos de ruptura se definen utilizando quantiles() en age_years. A continuación, mostramos los resultados utilizando tabyl() de **janitor** para que pueda ver los porcentajes (véase la página de [tablas descriptivas](#descriptive-tables)). Observe cómo no son exactamente el 10% en cada grupo. 

Grupos de tamaño uniforme 

Otra herramienta para hacer grupos numéricos es la función **dplyr** ntile(), que intenta dividir los datos en n *grupos de tamaño uniforme -* pero ten en cuenta que, a diferencia de *quantile(),* el mismo valor podría aparecer en más de un grupo*.* Proporcione el vector numérico y luego el número de grupos. Los valores de la nueva columna creada son sólo "números" de grupo (por ejemplo, del 1 al 10), no el rango de valores en sí mismo como cuando se utiliza cut(). 

case_when() 

Es posible utilizar la función **dplyr** case_when() para crear categorías a partir de una columna numérica, pero es más fácil utilizar age_categories() de **epikit** o cut() porque éstas crearán un factor ordenado automáticamente. 

Si utiliza case_when(), por favor, revise el uso adecuado como se ha descrito anteriormente en la sección Re-codificar valores de esta página. También Ten en cuenta que todos los valores del lado derecho deben ser del mismo tipo. Por lo tanto, si quiere NA en el lado derecho debe escribir "Missing" o utilizar el valor especial NA_character_. 

Añadir a la cadena de tuberías 

A continuación, se añade el código para crear dos columnas categóricas de edad a la cadena de tuberías de limpieza: 

Añadir filas 

Uno a uno 

Añadir filas una a una manualmente es tedioso pero puede hacerse con add_row() de **dplyr**. Recuerde que cada columna debe contener valores de un solo tipo (ya sea carácter, numérico, lógico, etc.). Así que añadir una fila requiere matizar para mantener esto. 

Utilice .before y .after. para especificar la ubicación de la fila que deseas añadir. .before = 3 pondrá la nueva fila antes de la tercera fila actual. El comportamiento por defecto es añadir la fila al final. Las columnas no especificadas se dejarán vacías (NA). 

El nuevo *número de fila* puede parecer extraño ("...23") pero los números de fila de las filas preexistentes *han* cambiado. Por lo tanto, si utiliza el comando dos veces, examine/pruebe la inserción cuidadosamente. 

Si uno de los tipos que proporcionas está desactivado, verás un error como este: 

Error: No se puede combinar ..1$fecha de infección <fecha> y ..2$fecha de infección <carácter>. 

(al insertar una fila con un valor de fecha, recuerde envolver la fecha en la función as.Date() como as.Date("2020-10-10")). 

Encuadernar filas 

Para combinar conjuntos de datos uniendo las filas de un dataframe al fondo de otro dataframe, puedes utilizar bind_rows() de **dplyr**. Esto se explica con más detalle en la página [Unir datos](#joining-data). 

Filtrar filas 

Un paso típico de limpieza después de haber limpiado las columnas y recodificado los valores es *filtrar* el dataframe para filas específicas usando el verbo **dplyr** filter(). 

Dentro de filter(), especifique la lógica que debe ser TRUE para que se mantenga una fila en los datos. A continuación, mostramos cómo filtrar filas basándose en condiciones lógicas simples y complejas. 

Filtro simple 

Este sencillo ejemplo redefine linelist del dataframe como ella misma, habiendo filtrado las filas para que cumplan una condición lógica. **Sólo se conservan las filas en las que la declaración lógica dentro de los paréntesis se evalúa como TRUE.** 

En este ejemplo, la sentencia lógica es gender == "f", que pregunta si el valor de la columna gender es igual a "f" (distingue entre mayúsculas y minúsculas). 

Antes de aplicar el filtro, el número de filas del listado es nrow(linelist). 

Después de aplicar el filtro, el número de filas del listado es linelist %>% filter(gender == "f") %>% nrow(). 

Filtrar los valores que faltan 

Es bastante común querer filtrar las filas que tienen valores faltantes. Resiste la tentación de escribir filter(!is.na(columna) & !is.na(columna)) y utilice en su lugar la función de tidyr que está hecha a medida para este propósito: drop_na(). Si se ejecuta con paréntesis vacíos, elimina las filas con *cualquier* valor que falte. Como alternativa, puedes proporcionar los nombres de las columnas específicas que deben evaluarse para comprobar si faltan, o utilizar las funciones de ayuda "tidyselect" descritas [anteriormente](#clean_tidyselect). 

Consulta la página sobre [datos ausentes](#missing-data) para conocer muchas técnicas para analizar y gestionar los datos ausentes. 

Filtrar por número de fila 

En un dataframe o tibble, cada fila suele tener un "número de fila" que (cuando se ve en R Viewer) aparece a la izquierda de la primera columna. No es en sí misma una columna real en los datos, pero puede utilizarse en una sentencia filter(). 

Para filtrar en base al "número de fila", puedes utilizar la función **dplyr** row_number() con paréntesis abiertos como parte de una sentencia lógica de filtrado. A menudo se utiliza el operador %in% y un rango de números como parte de esa sentencia lógica, como se muestra a continuación. Para ver las *primeras* N filas, también puedes utilizar la función especial **de dplyr** head(). 

También puedes convertir los números de fila en una verdadera columna pasando su dataframe a la función **tibble** rownames_to_column() (no ponga nada en los paréntesis). 

Filtro complejo 

Se pueden construir sentencias lógicas más complejas utilizando paréntesis ( ), OR |, negación ! , %en%, y operadores AND &. Un ejemplo es el siguiente: 

Nota: Puedes utilizar el operador ! delante de un criterio lógico para negarlo. Por ejemplo, !is.na(columna) se evalúa como verdadero si el valor de la columna *no* falta. Del mismo modo, !column %in% c("a", "b", "c") es verdadero si el valor de la columna *no está* en el vector. 

Examinar los datos 

A continuación, se muestra un sencillo comando de una línea para crear un histograma de las fechas de inicio. Vea que un segundo brote más pequeño de 2012-2013 también está incluido en este conjunto de datos sin procesar. **Para nuestros análisis, queremos eliminar las entradas de este brote anterior.** 

Cómo manejan los filtros los valores numéricos y de fecha que faltan 

¿Podemos simplemente filtrar por date_onset a las filas posteriores a junio de 2013? **Precaución. La aplicación del código filter(date_onset > as.Date("2013-06-01")) eliminaría todas las filas de la epidemia posterior con una fecha de inicio ausente!** 

***PELIGRO:*** Filtrar a mayor que (>) o menor que (<) una fecha o número puede eliminar cualquier fila con valores faltantes (NA). Esto se debe a que NA es tratado como infinitamente grande y pequeño. 

*(Consulta la página sobre el [trabajo con fechas](#working-with-dates-1) para obtener más información sobre el trabajo con fechas y el paquete **lubridate**)* 

Diseñar el filtro 

Examinar una tabulación cruzada para asegurarse de que excluimos sólo las filas correctas: 

¿Qué otros criterios podemos filtrar para eliminar el primer brote (en 2012 y 2013) de los datos? Vemos que: 

* La primera epidemia en 2012 y 2013 ocurrió en el Hospital A, el Hospital B, y que también hubo 10 casos en el Hospital del Puerto. 

* Los hospitales A y B no tuvieron casos en la segunda epidemia, pero el Hospital del Puerto sí. 

Queremos excluir: 

* Las filas nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01"))) con inicio en 2012 y 2013 en cualquiera de los hospitales A, B o Puerto:  * Excluir nrow(linelist %>% filter(date_onset <     as.Date("2013-06-01"))) filas con inicio en 2012 y 2013  * Excluir nrow(linelist %>% filter(hospital %in% c('Hospital     A', 'Hospital B') & is.na(date_onset))) filas de los     hospitales A y B con fechas de inicio ausentes  * **No** excluir nrow(linelist %>% filter(!hospital %in%     c('Hospital A', 'Hospital B') & is.na(date_onset))) otras     filas con fechas de inicio ausentes. 

Comenzamos con un listado de nrow(linelist)\`. Aquí está nuestra declaración de filtro: 

Cuando volvemos a hacer la tabulación cruzada, vemos que los hospitales A y B se eliminan por completo, y los 10 casos del Hospital del Puerto de 2012 y 2013 se eliminan, y todos los demás valores son los mismos, tal y como queríamos. 

Se pueden incluir varias sentencias dentro de un comando de filtrado (separadas por comas), o siempre se puede canalizar a un comando filter() separado para mayor claridad. 

*Nota: algunos lectores pueden notar que sería más fácil filtrar sólo por date_hospitalisation porque es 100% completo sin valores faltantes. Esto es cierto. Pero date_onset se utiliza para demostrar un filtro complejo.* 

Independiente 

El filtrado también puede realizarse como un comando independiente (no como parte de una cadena de tuberías). Como otros verbos **de dplyr**, en este caso el primer argumento debe ser el propio conjunto de datos. 

También puedes utilizar la **base** R para hacer un subconjunto utilizando corchetes que reflejen las [filas, columnas] que deseas conservar. 

Revisar rápidamente los registros 

A menudo se quiere revisar rápidamente unos pocos registros, para sólo unas pocas columnas. La función **base de** R View() imprimirá un dataframe para su visualización en su RStudio. 

Vea linelist en RStudio: 

Aquí hay dos ejemplos de visualización de celdas específicas (filas específicas y columnas específicas): 

**Con las funciones dplyr filter() y select():** 

Dentro de View(), canaliza los datos a filter() para mantener ciertas filas, y luego a select() para mantener ciertas columnas. Por ejemplo, para revisar las fechas de inicio y hospitalización de 3 casos específicos: 

Puedes lograr lo mismo con la sintaxis **básica** de R, utilizando los corchetes [ ] para el subconjunto que deseas ver. 

Añadir a la cadena de tuberías 

Cálculos por filas 

Si deseas realizar un cálculo dentro de una fila, puedes utilizar rowwise() de **dplyr**. Consulta esta viñeta en línea sobre los cálculos [por filas](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html).\ Por ejemplo, este código aplica rowwise() y luego crea una nueva columna que suma el número de las columnas de síntomas especificadas que tienen valor "sí", para cada fila del listado. Las columnas se especifican dentro de sum() por su nombre dentro de un vector c(). rowwise() es esencialmente un tipo especial de group_by(), por lo que es mejor utilizar ungroup() cuando haya terminado (página sobre [Agrupar datos](#grouping-data)). 

Al especificar la columna a evaluar, puedes utilizar las funciones de ayuda "tidyselect" descritas en la sección select() de esta página. Sólo tiene que hacer un ajuste (porque no las está utilizando dentro de una función **de dplyr** como select() o summarise()). 

Ponga los criterios de especificación de la columna dentro de la función **dplyr** c_across(). Esto se debe a que c_across ([documentación](https://dplyr.tidyverse.org/reference/c_across.html)) está diseñada para trabajar con rowwise() específicamente. Por ejemplo, el siguiente código: 

* Aplica rowwise() para que la siguiente operación (sum()) se aplique dentro de cada fila (no sumando columnas enteras) 

* Crea una nueva columna num_NA_dates, definida para cada fila como el número de columnas (con nombre que contiene "fecha") para las que is.na() se evaluó como TRUE (son valores faltantes). 

* ungroup() para eliminar los efectos de rowwise() en los pasos siguientes 

También podría proporcionar otras funciones, como max() para obtener la fecha más reciente o más reciente de cada fila: 

Ordenar y clasificar 

Utilice la función **dplyr** arrange() para ordenar las filas por los valores de las columnas. 

Lista simple de las columnas en el orden en que deben ser ordenadas. Especifique .by_group = TRUE si deseas que la ordenación se realice primero por cualquier *agrupación aplicada* a los datos (véase la página sobre [Agrupar datos](#grouping-data)). 

Por defecto, la columna se ordenará en orden "ascendente" (que se aplica a las columnas numéricas y también a las de caracteres). Puedes ordenar una variable en orden "descendente" envolviéndola con desc(). 

La ordenación de los datos con arrange() es particularmente útil cuando se hacen [Tablas para su presentación](#tables-for-presentation), utilizando slice() para tomar las filas "superiores" por grupo, o estableciendo el orden de los niveles de los factores por orden de aparición. 

Por ejemplo, para ordenar las filas de nuestra lista de líneas por hospital y luego por fecha de inicio en orden descendente, utilizaríamos 