[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-para-epidemiología-aplicada-y-salud-pública","chapter":"","heading":"R para epidemiología aplicada y salud pública","text":"ADVERTENCIA: Esta traducción está en proceso de elaboración. La primera fase de pre-traducción se ha realizado con DeepL.com. esa traducción automática se le hicieron algunas correcciones globales. Los capítulos en cuyo título aparece la palabra Borrador contienen esa información y se han ccorregido todavía. Los capítulos que aparecen en español ya están corregidos, aunque podría haber todavía alguna errata. Los capítulos cuyo título está en inglés, están pendientes todavía. Este manual pretende:Servir como breve guía de referencia para escribir código en RProporcionar ejemplos detallados que aborden problemas epidemiológicos.Ayudar profesionales de la epidemiología en su transición RSer accesible en entornos con baja conectividad Internet través de una versión sin conexión\nIdiomas: Inglés, Vietnamita (Tiếng Việt)\n \nEscrito y traducido por profesionales de la epidemiología, para profesionales de la epidemiologíaSomos epi’s de campo de todo el mundo, escribiendo en nuestro tiempo libre para ofrecer este recurso la comunidad. Tu apoyo y comentarios son muy bienvenidos:Cuestionario onlineEnvía un email epiRhandbook@gmail.com o un tweet @epiRhandbookEnvía problemas nuestro Repositorio Github","code":""},{"path":"index.html","id":"how-to-use-this-handbook","chapter":"","heading":"Cómo utilizar este manual","text":"Navega por las páginas del índice o utiliza el cuadro de búsquedaClica en los iconos “Copy” para copiar el códigoPuedes seguir paso paso las lecciones utilizando nuestros [datos de ejemplo][Download handbook data]Consulta la sección “Recursos” de cada página para obtener más materialVersión sin conexiónConsulta las instrucciones en la página de Descargar el Manual y los datos.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Agradecimientos","text":"Este manual ha sido elaborado mediante la colaboración de profesionales de la epidemiología de todo el mundo, basándonos en nuestra experiencia en organismos sanitarios locales, estatales, provinciales y nacionales, la Organización Mundial de la Salud (OMS), Médicos Sin Fronteras (MSF), sistemas hospitalarios e instituciones académicas.Este manual es un producto aprobado por ninguna organización específica. Aunque nos esforzamos por ser precisos, ofrecemos ninguna garantía sobre el contenido de este libro.","code":""},{"path":"index.html","id":"colaboradores","chapter":"","heading":"Colaboradores","text":"Redactor jefe: Neale BatraEquipo central del proyecto: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaEquipo de traducción al español: Juan Carlos Fernández-Merino, Juan Francisco Monteagudo, Ximena Tolosa, Luis Hernando Aguilar Ramirez, Ignacio Castro Aguirre, Esther Kukielka, Cristina Torró, Ana Fernández-Ayuso.Illustraciones: Calder Fong","code":""},{"path":"index.html","id":"financiación-y-apoyo","chapter":"","heading":"Financiación y apoyo","text":"El manual recibió apoyo financiaciero de TEPHINET, la red mundial de Programas de Formación en Epidemiología de Campo (FETP) través de una subvención para el desarrollo de capacidades de emergencia COVID-19.La Red de Antiguos Alumnos de (EAN) proporcionó apoyo administrativo, con un agradecimiento especial Annika Wendland. EPIET es el Programa Europeo de Formación en Epidemiología de Intervención.Un agradecimiento especial Médicos Sin Fronteras (MSF) Centro Operativo de Ámsterdam (OCA) por su apoyo durante la elaboración de este manual.Esta publicación fue respaldada por el Acuerdo de Cooperación número NU2GGH001873, financiado por los Centros para el Control y la Prevención de Enfermedades través de TEPHINET, un programa de Task Force Global Health. Su contenido es responsabilidad exclusiva de los autores y representa necesariamente las opiniones oficiales de los Centros para el Control y la Prevención de Enfermedades, el Departamento de Salud y Servicios Humanos, Task Force Global Health, Inc. o TEPHINET.","code":""},{"path":"index.html","id":"inspiración","chapter":"","heading":"Inspiración","text":"Hay multitud de tutoriales y viñetas que aportaron conocimientos para el desarrollo del contenido del manual y se acreditan en sus respectivas páginas.De manera más general, las siguientes fuentes han servido de inspiración para este manual:El proyecto “R4Epis” (una colaboración entre MSF y RECON)R Epidemics Consortium (RECON)El libro R Data Science (R4DS), en español en este enlacebookdown: Creación de libros y documentos técnicos con R MarkdownNetlify alberga este sitio web","code":""},{"path":"index.html","id":"terms-of-use-and-contribution","chapter":"","heading":"Condiciones de uso y contribución","text":"","code":""},{"path":"index.html","id":"licencia","chapter":"","heading":"Licencia","text":"Esta obra está bajo una Licencia Internacional Creative Commons Attribution-NonCommercial-ShareAlike 4.0.Los cursos académicos y los programas de formación en epidemiología pueden utilizar este manual con sus estudiantes. Si tienes preguntas sobre el uso que se le va dar, envía un correo electrónico epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"cita-sugerida","chapter":"","heading":"Cita sugerida","text":"Batra, Neale, et al. Manual de R para Epidemiología. 2021. ","code":""},{"path":"index.html","id":"contribución","chapter":"","heading":"Contribución","text":"Si quieres hacer una contribución de contenido, por favor, ponte en contacto con nosotros primero través de Github o por correo electrónico. Estamos implementando un calendario de actualizaciones y estamos creando una guía para colaboradores.Ten en cuenta que el proyecto epiRhandbook se publica con un Código de Conducta del Colaborador . Al contribuir este proyecto, te comprometes respetar sus términos.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"univariate-and-multivariable-regression","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1 Borrador. Regresión univariante y multivariable","text":"ADVERTENCIA: Esta traducción es sólo un borrador de la traducción al español. Este documento tal cual está ha sido generado automáticamente con DeepL.com y se han hecho algunas correcciones globales. Está pendiente de una revisión completa. Esta página muestra como se pueden emplear las funciones de regresión de R base , como glm() y el paquete gtsummary para observar las asociaciones entre variables (por ejemplo, odds ratios, risk ratios y hazard ratios). También utiliza funciones como tidy() del paquete broom para limpiar los resultados de la regresión.Univariante: tablas de dos por dosEstratificado: estimaciones mantel-haenszelMultivariable: selección de variables, selección de modelos, tabla finalForest plotsPara la regresión de riesgos proporcionales de Cox, véase la página de análisis de supervivencia.NOTA: Utilizamos el término multivariable para referirnos una regresión con múltiples variables explicativas. En este sentido, un modelo multivariante sería una regresión con varios resultados - véase este editorial para más detalles.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"preparation-9","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.1 Preparación","text":"","code":""},{"path":"univariate-and-multivariable-regression.html","id":"cargar-paquetes","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Cargar paquetes","text":"Este trozo de código muestra la carga de los paquetes necesarios para realizar los análisis. En este manual se hace énfasis en en el empleo de p_load() de pacman, que instala el paquete si es necesario y lo carga para tu uso. Los paquetes ya instalados también pueden cargarse empleando library() de R base. Consulta la página sobre fundamentos de R para obtener más información sobre los paquetes de R.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  tidyverse,    # data management + ggplot2 graphics, \n  stringr,      # manipulate text strings \n  purrr,        # loop over objects in a tidy way\n  gtsummary,    # summary statistics and tests \n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  parameters,   # alternative to tidy up results from regressions\n  see          # alternative to visualise forest plots\n  )"},{"path":"univariate-and-multivariable-regression.html","id":"importar-datos","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Importar datos","text":"Importaremos los datos de casos de una epidemia de ébola simulada. Para seguir el proceso, clica aquí para descargar la base de datos linelist “limpia” (como archivo .rds). Importa tus datos con la función import() del paquete rio (la cual acepta múltiples tipos de archivos como .xlsx, .rds, .csv - Checa la página de importación y exportación para más detalles).continuación se muestran las primeras 50 filas de la base de datos linelist.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"univariate-and-multivariable-regression.html","id":"datos-limpios","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Datos limpios","text":"","code":""},{"path":"univariate-and-multivariable-regression.html","id":"almacenar-las-variables-explicativas","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Almacenar las variables explicativas","text":"Almacenamos en un vector de caracteres los nombres de las columnas explicativas. Esto se explicará más adelante.","code":"\n## define variables of interest \nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")"},{"path":"univariate-and-multivariable-regression.html","id":"convertir-a-1s-y-0s","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Convertir a 1’s y 0’s","text":"continuación convertimos las columnas explicativas de “sí”/“”, “m”/“f”, y “muerto”/“vivo” 1 / 0, para cumplir con las expectativas de los modelos de regresión logística. Para hacer esto de manera eficiente, utilizaremos across() de dplyr para transformar varias columnas la vez. La función que aplicamos cada columna es case_when() (también de dplyr) que aplica la lógica para convertir los valores especificados en 1’s y 0’s. Mira las secciones sobre across() y case_when() en la página de Limpieza de datos y funciones básicas).Nota: el “.” que aparece continuación representa la columna que está siendo procesada por across() en ese momento.","code":"\n## convert dichotomous variables to 0/1 \nlinelist <- linelist %>%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## for each column listed and \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## recode male, yes and death to 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## female, no and recover to 0\n      TRUE                            ~ NA_real_)    ## otherwise set to missing\n    )\n  )"},{"path":"univariate-and-multivariable-regression.html","id":"eliminar-las-filas-con-valores-perdidos","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Eliminar las filas con valores perdidos","text":"Para eliminar las filas con valores perdidos, se puede utilizar la función drop_na() de tidyr. Sin embargo, sólo queremos hacer esto para las filas las que les faltan valores en las columnas de interés.Lo primero que debemos hacer es asegurarnos de que nuestro vector explanatory_vars incluye la columna age (age habría producido un error en la operación anterior case_when(), que sólo era para variables dicotómicas). continuación, escribimos un pipe uniendo linelist con drop_na() para eliminar cualquier fila con valores perdidos en la columna outcome o en cualquiera de las columnas explanatory_vars.Antes de ejecutar el código, podemos comprobar el número de filas inicial de linelist empleando nrow(linelist).El número de filas que quedan en linelist tras la operación es nrow(linelist).","code":"\n## add in age_category to the explanatory vars \nexplanatory_vars <- c(explanatory_vars, \"age_cat\")\n\n## drop rows with missing information for variables of interest \nlinelist <- linelist %>% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))"},{"path":"univariate-and-multivariable-regression.html","id":"univariate","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.2 Univariante","text":"Al igual que en la página sobre Tablas descriptivas, en función de la tarea que vayas realizar, podrás elegir que función emplear. continuación presentamos dos opciones para realizar análisis univariantes:Puedes utilizar las funciones disponibles en R base para imprimir rápidamente los resultados en la consola. Después, puedes utilizar el paquete broom para convertir esos outputs formato tidy.Puedes utilizar las funciones disponibles en R base para imprimir rápidamente los resultados en la consola. Después, puedes utilizar el paquete broom para convertir esos outputs formato tidy.Puedes utilizar el paquete gtsummary para modelar y obtener resultados en tablas listas para su publicación.Puedes utilizar el paquete gtsummary para modelar y obtener resultados en tablas listas para su publicación.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"r-base","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"R base","text":"","code":""},{"path":"univariate-and-multivariable-regression.html","id":"regresión-lineal","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Regresión lineal","text":"La función lm() de R base realiza una regresión lineal, evaluando la relación entre la respuesta numérica y las variables explicativas que se supone tienen una relación lineal.Para ello, proporciona la ecuación como una fórmula, con los nombres de las columnas de respuesta y explicativa separados por una tilde ~. Además, especifica la base de datos data =. Finalmente, defina los resultados del modelo como un objeto R, para poder utilizarlos más tarde.continuación, puedes ejecutar summary() en los resultados del modelo para ver los coeficientes (estimaciones), el valor P, los residuos y otras medidas.También se puede utilizar la función tidy() del paquete broom para obtener los resultados en una tabla. Lo que nos dicen los resultados es que por cada año de aumento de la edad la altura aumenta 3,5 cm y esto es estadísticamente significativo.También puedes utilizar esta regresión para añadirla un ggplot, para hacer esto, primero juntamos los puntos de los datos observados y la línea ajustada en un dataframe utilizando la función augment() de broom.También es posible añadir una simple recta de regresión lineal en ggplot utilizando la función geom_smooth().Consulta la sección de recursos al final de este capítulo para obtener tutoriales más detallados.","code":"\nlm_results <- lm(ht_cm ~ age, data = linelist)\nsummary(lm_results)## \n## Call:\n## lm(formula = ht_cm ~ age, data = linelist)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -128.579  -15.854    1.177   15.887  175.483 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  69.9051     0.5979   116.9   <2e-16 ***\n## age           3.4354     0.0293   117.2   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 23.75 on 4165 degrees of freedom\n## Multiple R-squared:  0.7675, Adjusted R-squared:  0.7674 \n## F-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: < 2.2e-16\ntidy(lm_results)## # A tibble: 2 x 5\n##   term        estimate std.error statistic p.value\n##   <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n## 1 (Intercept)    69.9     0.598       117.       0\n## 2 age             3.44    0.0293      117.       0\n## pull the regression points and observed data in to one dataset\npoints <- augment(lm_results)\n\n## plot the data using age as the x-axis \nggplot(points, aes(x = age)) + \n  ## add points for height \n  geom_point(aes(y = ht_cm)) + \n  ## add your regression line \n  geom_line(aes(y = .fitted), colour = \"red\")\n## add your data to a plot \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## show points\n  geom_point() + \n  ## add a linear regression \n  geom_smooth(method = \"lm\", se = FALSE)## `geom_smooth()` using formula 'y ~ x'"},{"path":"univariate-and-multivariable-regression.html","id":"regresión-logística","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Regresión logística","text":"La función glm() del paquete stats (parte de R base) se utiliza para ajustar los modelos lineales generalizados (GLM).glm() puede utilizarse para la regresión logística univariante y multivariable (por ejemplo, para obtener Odds Ratios). Aquí están las partes principales:formula = El modelo se proporciona glm() como una ecuación, con el resultado la izquierda y las variables explicativas la derecha de una tilde ~.family = Determina el tipo de modelo ejecutar. Para la regresión logística, utiliza family = \"binomial\", para poisson utiliza family = \"poisson\". Otros ejemplos se encuentran en la tabla siguiente.data = Especifica tu base de datos.Si es necesario, también puede especificar la función de enlace mediante la sintaxis family = familytype(link = \"linkfunction\")). Puedes leer más en la documentación sobre otras familias y argumentos opcionales como weights = y subset = (?glm).Cuando se ejecuta glm() lo más habitual es guardar los resultados como un objeto R. continuación, se pueden imprimir los resultados en la consola utilizando summary() como se muestra continuación, o realizar otras operaciones con los resultados (por ejemplo, exponenciar).Si necesitas ejecutar una regresión binomial negativa, puede utilizar el paquete MASS; el cual contiene la función glm.nb() que utiliza la misma sintaxis que glm().Para un recorrido por diferentes regresiones, consulta la página de estadísticas de UCLA.","code":"\n# arguments for glm()\nglm(formula, family, data, weights, subset, ...)"},{"path":"univariate-and-multivariable-regression.html","id":"univariante-glm","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Univariante glm()","text":"En este ejemplo estamos evaluando la asociación entre diferentes categorías de edad y el resultado de muerte (codificado como 1 en la sección anterior “Preparación”). continuación se muestra un modelo univariante de outcome por age_cat. Guardamos la salida del modelo como model y luego la imprimimos con summary() en la consola. Observe que las estimaciones proporcionadas son las probabilidades logarítmicas (log odds) y que el nivel de referencia es el primer nivel del factor age_cat (“0-4”).Para modificar el nivel de referencia de una variable determinada, asegúrate de que la columna es del tipo Factor y mueve el nivel deseado la primera posición con fct_relevel() (véase la página sobre Factores). Por ejemplo, continuación tomamos la columna age_cat y establecemos “20-29” como línea de base antes de conectar mediante pipes el dataframe modificado con glm().","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)   \n## (Intercept)   0.233738   0.072805   3.210  0.00133 **\n## age_cat5-9   -0.062898   0.101733  -0.618  0.53640   \n## age_cat10-14  0.138204   0.107186   1.289  0.19726   \n## age_cat15-19 -0.005565   0.113343  -0.049  0.96084   \n## age_cat20-29  0.027511   0.102133   0.269  0.78765   \n## age_cat30-49  0.063764   0.113771   0.560  0.57517   \n## age_cat50-69 -0.387889   0.259240  -1.496  0.13459   \n## age_cat70+   -0.639203   0.915770  -0.698  0.48518   \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4\nlinelist %>% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %>% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %>% \n  summary()## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##              Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)   0.26125    0.07163   3.647 0.000265 ***\n## age_cat0-4   -0.02751    0.10213  -0.269 0.787652    \n## age_cat5-9   -0.09041    0.10090  -0.896 0.370220    \n## age_cat10-14  0.11069    0.10639   1.040 0.298133    \n## age_cat15-19 -0.03308    0.11259  -0.294 0.768934    \n## age_cat30-49  0.03625    0.11302   0.321 0.748390    \n## age_cat50-69 -0.41540    0.25891  -1.604 0.108625    \n## age_cat70+   -0.66671    0.91568  -0.728 0.466546    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4"},{"path":"univariate-and-multivariable-regression.html","id":"imprimir-resultados","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Imprimir resultados","text":"En la mayoría de los casos, para su empleo posterior, es necesario hacer modificaciones los resultados obtenidos anteriormente. La función tidy() del paquete broom es útil de cara hacer más presentables los resultados de nuestros modelos.Aquí demostramos cómo combinar los resultados del modelo con una tabla de recuento.Obtenga las estimaciones de log odds ratio exponenciadas y los intervalos de confianza pasando el modelo tidy() y estableciendo exponentiate = TRUE y conf.int = TRUE.continuación, se muestra el objeto tibble model resultante:Combina estos resultados del modelo con una tabla de recuentos. continuación, creamos la tabla cruzada de recuentos con la función tabyl() de janitor, como se explica en la página de tablas descriptivas.Este es el aspecto de este dataframe counts_table:Ahora podemos unir counts_table y los resultados del model horizontalmente con bind_cols() (dplyr). Recuerda que con bind_cols() las filas de los dos dataframes deben estar perfectamente alineadas. En este código, como estamos enlazando mediante pipes, utilizamos . para representar el objeto counts_table mientras lo enlazamos con el modelo. Para terminar el proceso, utilizamos select() para elegir las columnas deseadas y determinar su orden, y finalmente aplicamos la función round() de R base en todas las columnas numéricas para especificar 2 decimales.Este es el aspecto del dataframe combinado, impreso de forma agradable como una imagen con una función de flextable. En Tablas para presentación se explica cómo personalizar dichas tablas con flextable, o bien puede utilizar otros numerosos paquetes como knitr o GT.","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %>% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # exponentiate and produce CIs\n  mutate(across(where(is.numeric), round, digits = 2))  # round all numeric columns\ncounts_table <- linelist %>% \n  janitor::tabyl(age_cat, outcome)\ncombined <- counts_table %>%           # begin with table of counts\n  bind_cols(., model) %>%              # combine with the outputs of the regression \n  select(term, 2:3, estimate,          # select and re-order cols\n         conf.low, conf.high, p.value) %>% \n  mutate(across(where(is.numeric), round, digits = 2)) ## round to 2 decimal places\ncombined <- combined %>% \n  flextable::qflextable()"},{"path":"univariate-and-multivariable-regression.html","id":"loops-con-múltiples-modelos-univariantes","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Loops con múltiples modelos univariantes","text":"continuación presentamos un método que utiliza glm() y tidy(). Para un enfoque más sencillo, véase la sección sobre gtsummary.Para ejecutar los modelos en varias variables de exposición para producir odds ratios univariantes (es decir, sin controlar entre sí), puede utilizar el enfoque siguiente. Utiliza str_c() de stringr para crear fórmulas univariantes (véase Caracteres y cadenas), ejecuta la regresión glm() en cada fórmula, pasa cada resultado de glm() tidy() y finalmente junta todos los resultados de los modelos resultantes con bind_rows() de tidyr. Este enfoque utiliza map() del paquete purrr para iterar - véase la página sobre Iteración, bucles y listas para más información sobre esta herramienta.Crea un vector de nombres de columnas de las variables explicativas. Ya lo tenemos como explanatory_vars de la sección de preparación de esta página.Crea un vector de nombres de columnas de las variables explicativas. Ya lo tenemos como explanatory_vars de la sección de preparación de esta página.Utiliza str_c() para crear múltiples fórmulas de cadena, con el resultado la izquierda, y un nombre de columna de explanatory_vars la derecha. El punto . sustituye al nombre de la columna en explanatory_vars.Utiliza str_c() para crear múltiples fórmulas de cadena, con el resultado la izquierda, y un nombre de columna de explanatory_vars la derecha. El punto . sustituye al nombre de la columna en explanatory_vars.Pasa estas fórmulas de cadena map() y establece ~glm() como la función aplicar cada entrada. Dentro de glm(), establece la fórmula de regresión como .formula(.x), donde .x se sustituirá por la fórmula de cadena definida en el paso anterior. map() realizará un bucle sobre cada una de las fórmulas de cadena, ejecutando regresiones para cada una.Pasa estas fórmulas de cadena map() y establece ~glm() como la función aplicar cada entrada. Dentro de glm(), establece la fórmula de regresión como .formula(.x), donde .x se sustituirá por la fórmula de cadena definida en el paso anterior. map() realizará un bucle sobre cada una de las fórmulas de cadena, ejecutando regresiones para cada una.Los resultados de este primer map() se pasan un segundo comando map(), que aplica tidy() los resultados de la regresión.Los resultados de este primer map() se pasan un segundo comando map(), que aplica tidy() los resultados de la regresión.Por último, la salida de la segunda función map() (una lista de dataframes ordenados) se condensa con bind_rows(), dando lugar un dataframe con todos los resultados univariantes.Por último, la salida de la segunda función map() (una lista de dataframes ordenados) se condensa con bind_rows(), dando lugar un dataframe con todos los resultados univariantes.Esta vez, el objeto final models es más largo porque ahora representa los resultados combinados de varias regresiones univariantes. Clica para ver todas las filas de model.Como antes, podemos crear una tabla de recuentos partir de linelist para cada variable explicativa, vincularla models y hacer una bonita tabla. Comenzamos con las variables, e iteramos través de ellas con map(). Iteramos través de una función definida por el usuario que implica la creación de una tabla de recuentos con funciones dplyr. Luego se combinan los resultados y se vinculan con los resultados del modelo models.continuación se muestra el aspecto del dataframe. Consulta la página sobre Tablas para presentación para obtener ideas sobre cómo convertir esta tabla en una bonita tabla HTML (por ejemplo, con flextable).","code":"\nexplanatory_vars %>% str_c(\"outcome ~ \", .)## [1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\" \n## [4] \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"  \n## [7] \"outcome ~ age_cat\"\nmodels <- explanatory_vars %>%       # begin with variables of interest\n  str_c(\"outcome ~ \", .) %>%         # combine each variable into formula (\"outcome ~ variable of interest\")\n  \n  # iterate through each univariate formula\n  map(                               \n    .f = ~glm(                       # pass the formulas one-by-one to glm()\n      formula = as.formula(.x),      # within glm(), the string formula is .x\n      family = \"binomial\",           # specify type of glm (logistic)\n      data = linelist)) %>%          # dataset\n  \n  # tidy up each of the glm regression outputs from above\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # exponentiate \n      conf.int = TRUE)) %>%          # return confidence intervals\n  \n  # collapse the list of regression outputs in to one data frame\n  bind_rows() %>% \n  \n  # round all numeric columns\n  mutate(across(where(is.numeric), round, digits = 2))\n## for each explanatory variable\nuniv_tab_base <- explanatory_vars %>% \n  map(.f = \n    ~{linelist %>%                ## begin with linelist\n        group_by(outcome) %>%     ## group data set by outcome\n        count(.data[[.x]]) %>%    ## produce counts for variable of interest\n        pivot_wider(              ## spread to wide format (as in cross-tabulation)\n          names_from = outcome,\n          values_from = n) %>% \n        drop_na(.data[[.x]]) %>%         ## drop rows with missings\n        rename(\"variable\" = .x) %>%      ## change variable of interest column to \"variable\"\n        mutate(variable = as.character(variable))} ## convert to character, else non-dichotomous (categorical) variables come out as factor and cant be merged\n      ) %>% \n  \n  ## collapse the list of count outputs in to one data frame\n  bind_rows() %>% \n  \n  ## merge with the outputs of the regression \n  bind_cols(., models) %>% \n  \n  ## only keep columns interested in \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% \n  \n  ## round decimal places\n  mutate(across(where(is.numeric), round, digits = 2))"},{"path":"univariate-and-multivariable-regression.html","id":"reg_gt_uni","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"paquete gtsummary","text":"continuación presentamos el uso de tbl_uvregression() del paquete gtsummary. Al igual que en la página sobre Tablas descriptivas, las funciones de gtsummary hacen un buen trabajo la hora de realizar estadísticas y producir outputs con aspecto profesional. Esta función produce una tabla de resultados de regresión univariante.Seleccionamos sólo las columnas necesarias de linelist (variables explicativas y la variable de resultado) y las introducimos en tbl_uvregression(). Vamos ejecutar una regresión univariante en cada una de las columnas que definimos como explanatory_vars en la sección de preparación de datos (sexo, fiebre, escalofríos, tos, dolores, vómitos y age_cat).Dentro de la propia función, proporcionamos el method = como glm (sin comillas), la columna de resultado y = (outcome), especificamos method.args = que queremos ejecutar la regresión logística través de family = binomial, y le decimos que exponencie los resultados.La salida es HTML y contiene el recuento de cada variable.Hay muchas modificaciones que se pueden hacer al output de esta tabla, como ajustar las etiquetas de texto, poner en negrita las filas por tu valor p, etc. Puedes consultar tutoriales aquí y en internet.","code":"\nuniv_tab <- linelist %>% \n  dplyr::select(explanatory_vars, outcome) %>% ## select variables of interest\n\n  tbl_uvregression(                         ## produce univariate table\n    method = glm,                           ## define regression want to run (generalised linear model)\n    y = outcome,                            ## define outcome variable\n    method.args = list(family = binomial),  ## define what type of glm want to run (logistic)\n    exponentiate = TRUE                     ## exponentiate to produce odds ratios (rather than log odds)\n  )\n\n## view univariate results table \nuniv_tab"},{"path":"univariate-and-multivariable-regression.html","id":"stratified","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.3 Estratificado","text":"El análisis estratificado se está trabajando actualmente para gtsummary, esta página se actualizará su debido tiempo.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"multivariable","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.4 Multivariable","text":"Para el análisis multivariable, volvemos presentar dos enfoques:glm() y tidy()paquete gtsummaryEl flujo de trabajo es similar para cada uno de ellos y sólo el último paso de elaborar una tabla final es diferente.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"realizar-análisis-multivariable","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Realizar análisis multivariable","text":"Aquí utilizamos glm() pero en este caso, añadiremos más variables al lado derecho de la ecuación, separadas por símbolos de suma (+).Para ejecutar el modelo con todas nuestras variables explicativas ejecutaríamos:Si quieres incluir dos variables y una interacción entre ellas puede separarlas con un asterisco * en lugar de un +. Si sólo especifica la interacción, sepárelas con dos puntos :. Por ejemplo:Opcionalmente, puedes utilizar este código para aprovechar el vector predefinido de nombres de columnas y volver crear el comando anterior utilizando str_c(). Esto puede ser útil si los nombres de sus variables explicativas cambian, o si quiere escribirlos todos de nuevo.","code":"\nmv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)## \n## Call:\n## glm(formula = outcome ~ gender + fever + chills + cough + aches + \n##     vomit + age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.383  -1.279   1.029   1.078   1.346  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)\n## (Intercept)   0.069054   0.131726   0.524    0.600\n## gender        0.002448   0.065133   0.038    0.970\n## fever         0.004309   0.080522   0.054    0.957\n## chills        0.034112   0.078924   0.432    0.666\n## cough         0.138584   0.089909   1.541    0.123\n## aches        -0.070705   0.104078  -0.679    0.497\n## vomit         0.086098   0.062618   1.375    0.169\n## age_cat5-9   -0.063562   0.101851  -0.624    0.533\n## age_cat10-14  0.136372   0.107275   1.271    0.204\n## age_cat15-19 -0.011074   0.113640  -0.097    0.922\n## age_cat20-29  0.026552   0.102780   0.258    0.796\n## age_cat30-49  0.059569   0.116402   0.512    0.609\n## age_cat50-69 -0.388964   0.262384  -1.482    0.138\n## age_cat70+   -0.647443   0.917375  -0.706    0.480\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5700.2  on 4153  degrees of freedom\n## AIC: 5728.2\n## \n## Number of Fisher Scoring iterations: 4\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n## run a regression with all variables of interest \nmv_reg <- explanatory_vars %>%  ## begin with vector of explanatory column names\n  str_c(collapse = \"+\") %>%     ## combine all names of the variables of interest separated by a plus\n  str_c(\"outcome ~ \", .) %>%    ## combine the names of variables of interest with outcome in formula style\n  glm(family = \"binomial\",      ## define type of glm as logistic,\n      data = linelist)          ## define your dataset"},{"path":"univariate-and-multivariable-regression.html","id":"construir-el-modelo","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Construir el modelo","text":"Puedes construir tu modelo paso paso, guardando varios modelos que incluyan determinadas variables explicativas. Puedes comparar estos modelos con pruebas de razón de verosimilitud utilizando lrtest() del paquete lmtest, como se indica continuación:NOTA: El uso de anova(model1, model2, test = \"Chisq\") de R base produce los mismos resultados Otra opción es tomar el objeto que contiene el modelo y aplicar la función step() del paquete stats. Especifica qué dirección de selección de variables deseas utilizar al construir el modelo.También puedes desactivar la notación científica en tu sesión de R, para mayor claridad:Como se describe en la sección sobre el análisis univariante, pasamos la salida del modelo tidy() para exponenciar las probabilidades logarítmicas y los IC. Finalmente, redondeamos todas las columnas numéricas dos decimales. Haz scroll para ver el resultado.Este es el aspecto del dataframe resultante:","code":"\nmodel1 <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 <- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)## Likelihood ratio test\n## \n## Model 1: outcome ~ age_cat\n## Model 2: outcome ~ age_cat + gender\n##   #Df  LogLik Df  Chisq Pr(>Chisq)\n## 1   8 -2852.6                     \n## 2   9 -2852.6  1 0.0002     0.9883\n## choose a model using forward selection based on AIC\n## you can also do \"backward\" or \"both\" by adjusting the direction\nfinal_mv_reg <- mv_reg %>%\n  step(direction = \"forward\", trace = FALSE)\noptions(scipen=999)\nmv_tab_base <- final_mv_reg %>% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## get a tidy dataframe of estimates \n  mutate(across(where(is.numeric), round, digits = 2))          ## round "},{"path":"univariate-and-multivariable-regression.html","id":"combinar-regresiones-univariantes-y-multivariables","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Combinar regresiones univariantes y multivariables","text":"","code":""},{"path":"univariate-and-multivariable-regression.html","id":"combinar-con-gtsummary","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Combinar con gtsummary","text":"El paquete gtsummary proporciona la función tbl_regression(), que toma los resultados de una regresión (glm() en este caso) y produce una bonita tabla resumen.Veamos la tabla:También puedes combinar varias tablas producidas por gtsummary con la función tbl_merge(). En este ejemplo combinaremos los resultados multivariables con los resultados univariantes de gtsummary que creamos anteriormente:","code":"\n## show results table of final regression \nmv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)## ! Use of `vars()` is now deprecated and support will soon be removed. Please replace calls to `vars()` with `c()`.\nmv_tab## Warning: Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## combine with univariate results \ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # set header names## ! Use of `vars()` is now deprecated and support will soon be removed. Please replace calls to `vars()` with `c()`.\n## ! Use of `vars()` is now deprecated and support will soon be removed. Please replace calls to `vars()` with `c()`.## Warning: Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead.\n## Since gt v0.6.0 the `fmt_missing()` function is deprecated and will soon be\n## removed.\n## * Use the `sub_missing()` function instead."},{"path":"univariate-and-multivariable-regression.html","id":"combinar-con-dplyr","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Combinar con dplyr","text":"Una forma alternativa de combinar los resultados univariables y multivariables de glm()/tidy() es con las funciones join de dplyr.Unir los resultados univariantes obtenidos anteriormente (univ_tab_base, que contiene los recuentos) con los resultados multivariables en formato tidy mv_tab_baseUtiliza select() para mantener sólo las columnas que queremos, especificar su orden y renombrarlasEmpleamos round() con dos decimales en todas las columnas que sean de tipo Double","code":"\n## combine univariate and multivariable tables \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %>% \n  ## choose columns and rename them\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %>% \n  mutate(across(where(is.double), round, 2))   ## # A tibble: 20 x 11\n##    characte~1 recov~2  dead univ_or univ_~3 univ_~4 univ_~5 mv_or mvv_c~6 mv_ci~7\n##    <chr>        <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>\n##  1 (Intercep~     909  1168    1.28    1.18    1.4     0     1.07    0.83    1.39\n##  2 gender         916  1174    1       0.88    1.13    0.97  1       0.88    1.14\n##  3 (Intercep~     340   436    1.28    1.11    1.48    0     1.07    0.83    1.39\n##  4 fever         1485  1906    1       0.85    1.17    0.99  1       0.86    1.18\n##  5 (Intercep~    1472  1877    1.28    1.19    1.37    0     1.07    0.83    1.39\n##  6 chills         353   465    1.03    0.89    1.21    0.68  1.03    0.89    1.21\n##  7 (Intercep~     272   309    1.14    0.97    1.34    0.13  1.07    0.83    1.39\n##  8 cough         1553  2033    1.15    0.97    1.37    0.11  1.15    0.96    1.37\n##  9 (Intercep~    1636  2114    1.29    1.21    1.38    0     1.07    0.83    1.39\n## 10 aches          189   228    0.93    0.76    1.14    0.51  0.93    0.76    1.14\n## 11 (Intercep~     931  1144    1.23    1.13    1.34    0     1.07    0.83    1.39\n## 12 vomit          894  1198    1.09    0.96    1.23    0.17  1.09    0.96    1.23\n## 13 (Intercep~     338   427    1.26    1.1     1.46    0     1.07    0.83    1.39\n## 14 age_cat5-9     365   433    0.94    0.77    1.15    0.54  0.94    0.77    1.15\n## 15 age_cat10~     273   396    1.15    0.93    1.42    0.2   1.15    0.93    1.41\n## 16 age_cat15~     238   299    0.99    0.8     1.24    0.96  0.99    0.79    1.24\n## 17 age_cat20~     345   448    1.03    0.84    1.26    0.79  1.03    0.84    1.26\n## 18 age_cat30~     228   307    1.07    0.85    1.33    0.58  1.06    0.85    1.33\n## 19 age_cat50~      35    30    0.68    0.41    1.13    0.13  0.68    0.4     1.13\n## 20 age_cat70+       3     2    0.53    0.07    3.2     0.49  0.52    0.07    3.19\n## # ... with 1 more variable: mv_pval <dbl>, and abbreviated variable names\n## #   1: characteristic, 2: recovered, 3: univ_ci_low, 4: univ_ci_high,\n## #   5: univ_pval, 6: mvv_ci_low, 7: mv_ci_high"},{"path":"univariate-and-multivariable-regression.html","id":"forest-plot","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.5 Forest plot","text":"Esta sección muestra cómo producir un gráfico con los resultados de tu regresión.\nHay dos opciones, puedes construir un gráfico tú mismo usando ggplot2 o usar un metapaquete llamado easystats (un paquete que incluye muchos paquetes).Consulta la página sobre Conceptos básicos de ggplot si estás familiarizado con el paquete de gráficos ggplot2.","code":""},{"path":"univariate-and-multivariable-regression.html","id":"paquete-ggplot2","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Paquete ggplot2","text":"Puedes construir un gráfico de bosque con ggplot() trazando elementos de los resultados de la regresión multivariable. Añada las capas de los gráficos utilizando estos “geoms”:estimaciones con geom_point()intervalos de confianza con geom_errorbar()una línea vertical en = 1 con geom_vline()Antes de empezar plottear, es posible que sea necesario utilizar fct_relevel() del paquete forcats para establecer el orden de las variables/niveles en el eje y. De establecer un orden en las variables, ggplot() podría mostrar las variables en orden alfanumérico, lo que funcionaría bien para los valores de categoría de edad (“30” aparecería antes de “5”). Mira la página sobre Factores para más detalles.","code":"\n## remove the intercept term from your multivariable results\nmv_tab_base %>% \n  \n  #set order of levels to appear along y-axis\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %>%\n  \n  # remove \"intercept\" row from plot\n  filter(term != \"(Intercept)\") %>% \n  \n  ## plot with variable on the y axis and estimate (OR) on the x axis\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## show the estimate as a point\n  geom_point() + \n  \n  ## add in an error bar for the confidence intervals\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## show where OR = 1 is for reference as a dashed line\n  geom_vline(xintercept = 1, linetype = \"dashed\")"},{"path":"univariate-and-multivariable-regression.html","id":"paquetes-easystats","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"Paquetes easystats","text":"Una alternativa, si deseas el nivel de precisión y control que proporciona ggplot2, es utilizar una combinación de paquetes easystats.La función model_parameters() del paquete parameters hace el equivalente de la función tidy() del paquete broom. El paquete see acepta esos resultados y crea por defecto un forest plot, dándo como output un objeto ggplot().","code":"\npacman::p_load(easystats)\n\n## remove the intercept term from your multivariable results\nfinal_mv_reg %>% \n  model_parameters(exponentiate = TRUE) %>% \n  plot()"},{"path":"univariate-and-multivariable-regression.html","id":"resources-11","chapter":"1 Borrador. Regresión univariante y multivariable","heading":"1.6 Recursos","text":"El contenido de esta página se ha basado en estos recursos y viñetas:Regresión lineal en RgtsummaryPágina de estadísticas de la UCLAregresión escalonada sthda","code":""}]
