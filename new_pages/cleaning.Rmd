# Limpieza de datos y funciones básicas {#cleaning-data-and-core-functions} 

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Esta página muestra los pasos más utilizados en el proceso de "limpieza" de datos, y también explica el uso de muchas funciones esenciales de gestión de datos en R. 

Para explicarlo, esta página comienza importando datos de un listado de casos crudo, y se avanza paso a paso a través del proceso de limpieza. En el código R, esto se manifiesta como una cadena de "tuberías", que hacen referencia al operador "tuberías" `%>%` que pasa unos datos de una operación a la siguiente. 

### Funciones principales  {.unnumbered}

Este manual hace hincapié en el uso de las funciones de la familia de paquetes de R [**tidyverse**](https://www.tidyverse.org/). Las funciones esenciales que se muestran en esta página se enumeran a continuación. 

Muchas de estas funciones pertenecen al paquete [**dplyr**](https://dplyr.tidyverse.org/), que proporciona funciones "verbales" para resolver los retos de la manipulación de datos (el nombre hace una referencia a unos alicates - [plier](https://www.thefreedictionary.com/plier#:~:text=also ply·er (plī′,holding%2C bending%2C or cutting.)) - de dataframes). **dplyr** forma parte de la familia de paquetes de R **tidyverse** (que también incluye **ggplot2**, **tidyr**, **stringr**, **tibble**, **purrr**, **magrittr** y **forcats**, entre otros). 


Función      | Utilidad                             | Paquete
-------------|--------------------------------------|------------------------------
[%>%](https://magrittr.tidyverse.org/reference/pipe.html) | "canalizar" (pasar) datos de una función a la siguiente | **magrittr**   
[mutate()](https://dplyr.tidyverse.org/reference/mutate.html) | crear, transformar y redefinir columnas | **dplyr**   
[selecct()](https://dplyr.tidyverse.org/reference/select.html) | mantener, eliminar, seleccionar o renombrar columnas | **dplyr**  
[rename()](https://dplyr.tidyverse.org/reference/rename.html) | cambiar el nombre de las columnas | **dplyr**  
clean_names() | estandarizar la sintaxis de los nombres de las columnas | **janitor** 
[as.character()](https://rdrr.io/r/base/character.html), [as.numeric()](https://rdrr.io/r/base/numeric.html), [as.Date()](https://rdrr.io/r/base/as.Date.html), etc. | convertir el tipo de una columna | R **base**
across() | transformar varias columnas a la vez | **dplyr**   
funciones **tidyselect** | utilizar la lógica para seleccionar las columnas | **tidyselect**
[filter()](https://dplyr.tidyverse.org/reference/filter.html) | mantener ciertas filas | **dplyr**  
[distinct()](https://dplyr.tidyverse.org/reference/distinct.html) | de-duplicar filas | **dplyr**  
rowwise() | operaciones por/en cada fila | **dplyr**   
add_row() | añadir filas manualmente | **tiblle**   
[arrange()](https://dplyr.tidyverse.org/reference/arrange.html) | ordenar las filas | **dplyr**   
recode() |recodificar los valores de una columna | **dplyr**   
case_when() | recodificar los valores de una columna con criterios lógicos más complejos | **dplyr**   
replace_na(), na_if(), coalesce() | funciones especiales de recodificación | **tidyr**   
age_categories() y [cut()](https://rdrr.io/r/base/cut.html) | crear grupos categóricos a partir de una columna numérica | **epikit** y R **base**
clean_variable_spelling() | recodificación/limpieza de valores mediante un diccionario de datos | **lista de líneas**   
[which()](https://rdrr.io/r/base/which.html) | aplicar los criterios lógicos; devolver los índices | R **base**

Si quieres ver cómo se comparan estas funciones con los comandos de Stata o SAS, consulta la página sobre la [transición a R](#transition-to-r). 

Puedes encontrar una gestión de datos alternativa en el paquete R **data.table** con operadores como `:=` y el uso frecuente de corchetes `[ ]`. Este enfoque y la sintaxis se explican brevemente en la página [Data.Table](#data-table). 

### Nomenclatura {.unnumbered} 

En este manual, generalmente hacemos referencia a "columnas" y "filas" en lugar de "variables" y "observaciones". Como se explica en este manual sobre ["datos ordenados"](https://tidyr.tidyverse.org/articles/tidy-data.html), la mayoría de los conjuntos de datos estadísticos epidemiológicos se componen estructuralmente de filas, columnas y valores. 

Las *variables* contienen los valores que miden el mismo atributo subyacente (como el grupo de edad, el resultado o la fecha de inicio). Las *observaciones* contienen todos los valores medidos en la misma unidad (por ejemplo, una persona, un lugar o una muestra de laboratorio). Por lo tanto, estos aspectos pueden ser más difíciles de definir de forma tangible. 

En los conjuntos de datos "ordenados", cada columna es una variable, cada fila es una observación y cada celda es un único valor. Sin embargo, algunos conjuntos de datos que se encuentran no se ajustan a este molde: unos datos de formato "amplio" pueden tener una variable dividida en varias columnas (véase un ejemplo en la página [Pivotar datos](#pivoting-data)). Del mismo modo, las observaciones pueden estar divididas en varias filas. 

La mayor parte de este manual trata sobre la gestión y la transformación de datos, por lo que las referencias a las estructuras de datos concretas de filas y columnas son más relevantes que las observaciones y las variables más abstractas. Las excepciones se dan sobre todo en las páginas sobre análisis de datos, en las que verás más referencias a las variables y las observaciones. 

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Limpieza de tuberías {#cleaning-pipeline}

**Esta página recorre los pasos típicos de limpieza, añadiéndolos secuencialmente a una cadena de tuberías de limpieza.** 

En el análisis epidemiológico y el procesamiento de datos, los pasos de limpieza se realizan a menudo de forma secuencial, enlazados entre sí. En R, esto se manifiesta a menudo como una "tubería" de limpieza, en la que *los datos en bruto se pasan o se "canalizan" de un paso de limpieza a otro*. 

Estas cadenas utilizan las funciones de **dplyr** y el operador `%>%` de **magrittr**. Esta tubería comienza con los datos "en bruto" ("linelist_raw.xlsx") y termina con un dataframe de R "limpio" (`linelist`) que se puede utilizar, guardar, exportar, etc. 

En un proceso de limpieza, el orden de los pasos es importante. Los pasos de limpieza pueden incluir: 

* Importación de datos 
* Limpieza o cambio de los nombres de las columnas 
* de-duplicación 
* Creación y transformación de columnas (por ejemplo, recodificación o normalización de valores) 

* Filtrado o añadido de filas 


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Carga de paquetes  {#load-packages}

Este trozo de código muestra la carga de los paquetes necesarios para el análisis. En este manual destacamos `p_load()` de **pacman**, que instala el paquete si es necesario *y* lo carga para su uso. También puedes cargar los paquetes instalados con `library()` de R **base.** Consulta la página sobre [Fundamentos de R](#r-basics) para obtener más información sobre los paquetes de R. 

```{r, message = F}
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse   # data management and visualization
)
```


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Importar datos {#import-data-1}

### Importar {.unnumbered} 

Aquí importamos el archivo Excel de la lista de casos "en bruto" utilizando la función `import()` del paquete **rio**. El paquete **rio** maneja con flexibilidad muchos tipos de archivos (por ejemplo, .xlsx, .csv, .tsv, .rds. Consulta la página sobre [importación y exportación](#import-and-export) para obtener más información y consejos sobre situaciones inusuales (por ejemplo, omitir filas, establecer valores que faltan, importar hojas de Google, etc). 

Para continuar, [cliquea para descargar linelist "en crudo"](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx) (como archivo .xlsx). 

Si tu conjunto de datos es grande y tarda mucho en importarse, puede ser útil que el comando de importación esté separado de la cadena de tuberías y que el "crudo" se guarde como un archivo distinto. Esto también permite comparar fácilmente las versiones original y limpia. 

A continuación, importamos el archivo de Excel sin procesar y lo guardamos como el dataframe `linelist_raw`. Suponemos que el archivo se encuentra en tu directorio de trabajo o en la raíz del proyecto R, por lo que no se especifican subcarpetas en la ruta del archivo. 


```{r, echo=F, message=F}
# HIDDEN FROM READER
# actually load the data using here()
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Puedes ver las primeras 50 filas del dataframe a continuación. Nota: la función **base** de R `head(n)` te permite ver sólo las primeras n filas en la consola de R. 

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Revisar {.unnumbered}  

Puedes utilizar la función `skim()` del paquete **skimr** para obtener una visión general de todo el dataframe (véase la página sobre [tablas descriptivas](#descriptive-tables) para más información). Las columnas se resumen por clase o tipo, como, por ejemplo, carácter, numérico. Nota: "POSIXct" es un tipo de fecha cruda (ver [Trabajar con fechas](#working-with-dates-1). 

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Nombres de columnas {#column-names}

En R, los *nombres* de las columnas son la "cabecera" o el valor "superior" de una columna. Se utilizan para referirse a las columnas en el código, y sirven como etiqueta por defecto en las figuras. 

Otros programas estadísticos, como SAS y STATA, utilizan *"etiquetas"* que coexisten como versiones impresas más largas de los nombres de columna más cortos. Aunque R ofrece la posibilidad de añadir etiquetas de columna a los datos, no es una práctica que sea muy utilizada. Para hacer que los nombres de las columnas sean "fáciles de imprimir" para las figuras, normalmente se ajusta su visualización dentro de los comandos de gráficas que crean las salidas (por ejemplo, los títulos de los ejes o de las leyendas de una gráfica, o las cabeceras de las columnas en una tabla impresa - véase la [sección de escalas de la página de consejos de ggplot](#ggplot_tips_scales) y las páginas de [Tablas para la presentación](#tables-for-presentation)). Si deseas asignar etiquetas de columna en los datos, lee más online [aquí](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) y [aquí](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html). 

Como los nombres de las columnas de R se utilizan con mucha frecuencia, deben tener una sintaxis "limpia". Sugerimos lo siguiente: 

* Nombres cortos 
* Sin espacios (sustituir por barras bajas _ ) 
* Sin caracteres inusuales (&, #, <, >, ...) 
* Nomenclatura de estilo similar (por ejemplo, todas las columnas de fecha nombradas como **date**_onset, **date**_report, **date**_death...) 

Los nombres de las columnas de `linelist_raw` se muestran a continuación utilizando `names()` de R **base**. Podemos ver que inicialmente 

* Algunos nombres contienen espacios (por ejemplo, `infection date`) 

* Se utilizan diferentes patrones de nomenclatura para las fechas (`date onset` vs. `infection date`) 

* Debe haber habido una *cabecera fusionada* en las dos últimas columnas del .xlsx. Lo sabemos porque el nombre de dos columnas fusionadas ("merged_header") fue asignado por R a la primera columna, y a la segunda columna se le asignó un nombre de marcador de posición "...28" (ya que entonces estaba vacía y es la columna 28). 

```{r}
names(linelist_raw)
```

<span style="color: black;">***NOTA:*** Para hacer referencia a un nombre de columna que incluya espacios, rodea el nombre con tildes, por ejemplo: linelist$`` ` '\x60infection date\x60'` ``. Ten en cuenta que, en tu teclado, la tilde (\`) es diferente de la comilla simple ('). </span>

### Limpieza automática {.unnumbered}  

La función `clean_names()` del paquete **janitor** estandariza los nombres de las columnas y los hace únicos haciendo lo siguiente: 

* Convierte todos los nombres para que estén compuestos sólo por barras bajas, números y letras 
* Los caracteres acentuados se transliteran a ASCII (por ejemplo, la o alemana con diéresis se convierte en "o", la "ñ" española se convierte en "n") 
* Se puede especificar la preferencia de mayúsculas para los nuevos nombres de columna utilizando `case =` argumento ("snake" es el valor por defecto, las alternativas incluyen "sentence", "title", "small_camel"...) 
* Puedes especificar sustituciones de nombres concretos proporcionando un vector `replace =` argumento (por ejemplo, `replace = c(onset = "date_of_onset")`)

* Aquí puedes encontrar una  [viñeta](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) en línea sobre dicho paquete. 

A continuación, el proceso de limpieza comienza utilizando `clean_names()` sobre linelist_raw. 

```{r clean_names}
# pipe the raw dataset through the function clean_names(), assign result as "linelist"  
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new column names
names(linelist)
```

<span style="color: black;">***NOTA:*** El nombre de la última columna "...28" se ha cambiado por "x28". </span>

### Limpieza manual de nombres {.unnumbered}  

A menudo es necesario renombrar las columnas manualmente, incluso después del paso de estandarización anterior. A continuación, el renombramiento se realiza utilizando la función `rename()` del paquete **dplyr**, como parte de una cadena de tuberías. `rename()` utiliza el estilo `NUEVO = ANTIGUO` - el nombre nuevo de la columna se escribe antes que el antiguo. 

A continuación, se añade un comando de renombramiento a la tubería de limpieza. Se han añadido espacios estratégicamente para alinear el código y facilitar la lectura. 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```


Ahora puedes ver que los nombres de las columnas han cambiado: 

```{r message=FALSE, echo=F}
names(linelist)
```

#### Renombrar por posición de columna {.unnumbered} 

También puedes renombrar por la posición de la columna, en lugar del nombre de la columna, por ejemplo: 

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### Renombrar mediante `select()` y `summarise()` {.unnumbered}

Como método abreviado, también puedes cambiar el nombre de las columnas dentro de las funciones de **dplyr** `select()` y `summarise()`. `select()` se utiliza para mantener sólo ciertas columnas (y se muestra más adelante en esta página). `summarise()` se muestra en las páginas [Agrupar datos](#grouping-data) y [Tablas descriptivas](#descriptive-tables). Estas funciones también utilizan el formato `nombre_nuevo = nombre_antiguo`. He aquí un ejemplo: 

```{r, eval=F}
linelist_raw %>% 
  select(# NEW name             # OLD name
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns
         date_hospitalisation = `hosp date`)
```

### Otros retos {.unnumbered} 

#### Nombres de columnas de Excel vacíos {.unnumbered} 

R no puede tener columnas de conjuntos de datos que no tengan nombres de columnas (cabeceras). Así, si importa unos datos de Excel con datos pero sin cabeceras de columna, R rellenará las cabeceras con nombres como "...1" o "...2". El nombre asignado representa el número de la columna (por ejemplo, si la cuarta columna de los datos no tiene cabecera, R la nombrará "...4"). 

Puedes limpiar estos nombres manualmente haciendo referencia a su número de posición (véase el ejemplo anterior), o a su nombre asignado (`linelist_raw$...1`). 

#### Nombres de columnas y celdas fusionadas de Excel {.unnumbered}

Las celdas combinadas en un archivo de Excel son una ocurrencia común cuando se reciben datos. Como se explica en [Transición a R](#transition-to-r), las celdas combinadas pueden ser agradables para la lectura humana de los datos, pero no son "datos ordenados" y causan muchos problemas para la lectura de los datos por parte de las máquinas. R no puede ajustar las celdas combinadas. 

Recuerda a las personas que introducen los datos que **los datos legibles para el ser humano no son lo mismo que los datos legibles para la máquina**. Esfuérzate en formar a los usuarios sobre los principios de los [**datos ordenados**](https://es.r4ds.hadley.nz/datos-ordenados.html). Si es posible, intenta cambiar los procedimientos para que los datos lleguen en un formato ordenado y sin celdas fusionadas. 

* Cada variable debe tener su propia columna. 
* Cada observación debe tener su propia fila. 
* Cada valor debe tener su propia celda. 

Al utilizar la función `import()` de **rio**, el valor de una celda combinada se asignará a la primera celda y las siguientes estarán vacías. 

Una solución para tratar las celdas combinadas es importar los datos con la función `readWorkbook()` del paquete **openxlsx**. Establece el argumento `fillMergedCells = TRUE`. Esto da el valor en una celda fusionada a todas las celdas dentro del rango de fusión. 

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

<span style="color: red;">***PELIGRO:*** Si los nombres de las columnas se fusionan con `readWorkbook()`, terminarás con nombres de columnas duplicados, que tendrás que arreglar manualmente - ¡R no funciona bien con nombres de columnas duplicados! Puedes renombrarlas haciendo referencia a su posición (por ejemplo, la columna 5), como se explica en la sección de limpieza manual de nombres de columnas. </span>




 

<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->

## Seleccionar o reordenar columnas {#select-or-re-order-columns} 

Utiliza `select()` de **dplyr** para seleccionar las columnas que deseas conservar y para especificar su orden en el dataframe. 

<span style="color: orange;">***ATENCIÓN:*** En los ejemplos siguientes, el dataframe `linelist` se modifica con `select()` y se muestra, pero no se guarda. Esto es a efectos de demostración. Los nombres de las columnas modificadas se imprimen pasando el dataframe a `names()`.</span>

**Aquí están TODOS los nombres de las columnas en linelist en este punto de la cadena de limpieza:** 

```{r}
names(linelist)
```

### Mantener las columnas {.unnumbered}  

**Selecciona sólo las columnas que desees conservar** 

Escribe sus nombres en el comando `select()`, sin comillas. Aparecerán en el dataframe en el orden que indiques. Ten en cuenta que si incluyes una columna que no existe, R devolverá un error (véase el uso de `any_of()` más adelante para evitar un error de este tipo). 

```{r}
# linelist dataset is piped through select() command, and names() prints just the column names
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # display the column names
```



### Funciones de ayuda "tidyselect" {#clean_tidyselect .unnumbered}

Estas funciones de ayuda existen para facilitar la especificación de las columnas a conservar, descartar o transformar. Provienen del paquete **tidyselect**, que se incluye en **tidyverse** y se basa en la forma en que se seleccionan las columnas en las funciones de **dplyr**. 

Por ejemplo, si deseas reordenar las columnas, `everything()` es una función útil para indicar "todas las demás columnas no mencionadas". El comando siguiente mueve las columnas `date_onset` y `date_hospitalisation` al principio (izquierda) de los datos, pero mantiene todas las demás columnas después. Fíjate en que `everything()` se escribe con paréntesis vacíos: 

```{r}
# move date_onset and date_hospitalisation to beginning
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Aquí hay otras funciones de ayuda "tidyselect" que también funcionan *dentro de* las funciones de **dplyr** como `select()`, `across()` y `summarise()`: 

* `everything()` - todas las demás columnas no mencionadas 
* `last_col()` - la última columna 
* `where()` - aplica una función a todas las columnas y selecciona las que son TRUE 
* `contains()` - columnas que contienen una cadena de caracteres
  * ejemplo: `select(contains("time"))`
* `starts_with()` - coincide con un prefijo especificado  
  * ejemplo: `select(starts_with("date_"))`
* `ends_with()` - coincide con un sufijo especificado  
  * ejemplo: `select(ends_with("_post))` 
* `matches()` - para aplicar una expresión regular (regex)  
  * ejemplo: `select(matches("[pt]al"))` 
* `num_range()` - un rango numérico como x01, x02, x03 
* `any_of()` - coincide con la columna SI existe pero no devuelve ningún error si no se encuentra
  * ejemplo: `select(any_of(date_onset, date_death,     cardiac_arrest)) `

Además, utiliza operadores normales como `c()` para listar varias columnas, `:` para columnas consecutivas, `!` para opuestas, `&` para "Y" y `|` para "O". 

Utiliza `where()` para especificar criterios lógicos para las columnas. Si escribes una función dentro de `where()`, no incluyas los paréntesis vacíos de la función. El comando siguiente selecciona las columnas de tipo Numeric. 

```{r}
# select columns that are class Numeric
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Utiliza `contains()` para seleccionar sólo las columnas en las que el nombre de la columna contiene una cadena de caracteres especificada. `ends_with()` y `starts_with()` proporcionan más matices. 

```{r}
# select columns containing certain characters
linelist %>% 
  select(contains("date")) %>% 
  names()
```

La función `matches()` funciona de forma similar a `contains()`, pero puede escribirse en una expresión regular (mira la página sobre [Caracteres y cadenas](#characters-and-strings)), como varias cadenas separadas por barras "O" dentro de los paréntesis: 

```{r}
# searched for multiple character matches
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

<span style="color: orange;">***ATENCIÓN:*** Si has escrito un nombre de columna y no existen datos para ella, puede devolver un error y detener tu código. Considera el uso de `any_of()` para citar columnas que pueden o no existir, especialmente útil en selecciones negativas (eliminar). </span>

Sólo existe una de estas columnas, pero no se produce ningún error y el código continúa sin detener su cadena de limpieza. 

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```


### Eliminar columnas {.unnumbered} 

**Indica qué columnas se van a eliminar** colocando el símbolo "-" delante del nombre de la columna (por ejemplo, `select(-outcome)`), o un vector de nombres de columnas (como se indica a continuación). Todas las demás columnas se mantendrán. 
```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # remove date_onset and all columns from fever to vomit
  names()
```

También puedes eliminar una columna utilizando la sintaxis de R **base**, definiéndola como `NULL`. Por ejemplo: 
```{r, eval=F}
linelist$date_onset <- NULL   # deletes column with base R syntax 
```



### Independiente {.unnumbered}

`select()` también puede utilizarse como un comando independiente (no en una cadena de tuberías). En este caso, el primer argumento es el dataframe original sobre el que se va a operar. 

```{r}
# Create a new linelist with id and age-related columns
linelist_age <- select(linelist, case_id, contains("age"))

# display the column names
names(linelist_age)
```



#### Añadir a la cadena de tuberías {.unnumbered}  

En `linelist_raw`, hay algunas columnas que no necesitamos: `row_num`, `merged_header` y `x28`. Las eliminamos con un comando `select()` en la cadena de tuberías de limpieza: 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################

    # remove column
    select(-c(row_num, merged_header, x28))
```




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## De-duplicación {#deduplication}

Consulta la página sobre [de-duplicación](#de-duplication) para ver la cantidad de opciones sobre cómo eliminar las duplicidades (de-duplicar). Aquí sólo se presenta un ejemplo muy sencillo de de-duplicación de filas. 

El paquete **dplyr** ofrece la función `distinct()`. Esta función examina cada fila y reduce el dataframe con sólo filas únicas. Es decir, elimina las filas que están 100% duplicadas. 

Al evaluar las filas duplicadas, tiene en cuenta un rango de columnas - por defecto considera todas las columnas. Como se muestra en la página de de-duplicación, puedes ajustar este rango de columnas para que la singularidad de las filas sólo se evalúe con respecto a determinadas columnas. 

En este sencillo ejemplo, simplemente añadimos el comando vacío `distinct()` a la cadena de tuberías. Esto garantiza que no haya filas que estén 100% duplicadas de otras filas (evaluadas en todas las columnas). 

Comenzamos con ` nrow(linelist)` filas en `linelist`. 

```{r}
linelist <- linelist %>% 
  distinct()
```

Después de la de-duplicación hay `nrow(linelist)` filas. Las filas eliminadas habrían sido 100% duplicados de otras filas. 

A continuación, se añade el comando `distinct()` a la cadena de tuberías de limpieza: 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################
    
    # de-duplicate
    distinct()
```





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Creación y transformación de columnas  {#column-creation-and-transformation}

**Recomendamos utilizar la función  `mutate()` de dplyr para añadir una nueva columna, o para modificar una existente.** 

A continuación se muestra un ejemplo de creación de una nueva columna con `mutate()`. La sintaxis es: `mutate(nombre_nueva_columna = valor o transformación) `

En Stata, esto es similar al comando `generate`, pero también se puede utilizar `mutate()` de R para modificar una columna existente. 


### Nuevas columnas  {.unnumbered}

El comando más básico de `mutate()` para crear una nueva columna podría tener este aspecto. Crea una nueva columna `new_col` donde el valor en cada fila es 10. 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

También puedes referenciar valores en otras columnas, para realizar cálculos. A continuación, se crea una nueva columna `bmi` para mantener el Índice de Masa Corporal (BMI) de cada caso - calculado mediante la fórmula `BMI = kg/m^2`, utilizando la columnas `ht_cm` y `wt_kg`. 

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Si creas varias columnas nuevas, separa cada una con una coma y una nueva línea. A continuación se muestran ejemplos de nuevas columnas, incluidas las que consisten en valores de otras columnas combinadas mediante `str_glue()` del paquete **stringr** (véase la página sobre [Caracteres y cadenas](#characters-and-strings).

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # new column = all values the same
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") # new column = pasting together values from other columns
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # show only new columns, for demonstration purposes
```


Revisa las columnas nuevas. A efectos de demostración, sólo se muestran las columnas nuevas y las utilizadas para crearlas:  


```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<span style="color: darkgreen;">***CONSEJO:*** Una variación de `mutate()` es la función `transmute()`. Esta función añade una nueva columna al igual que `mutate()`, pero también elimina todas las demás columnas que no se mencionan dentro de sus paréntesis. </span>


```{r, eval=F}
# HIDDEN FROM READER
# removes new demo columns created above
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```



### Convertir el tipo de columna  {.unnumbered}

Las columnas que contienen valores que son fechas, números o valores lógicos (TRUE/FALSE) sólo se comportarán como se espera si están correctamente clasificadas. Hay una diferencia entre "2" de tipo carácter y 2 de tipo numérico! 

Hay formas de establecer el tipo de la columna durante los comandos de importación, pero esto suele ser engorroso. Consulta la sección sobre los tipos de objeto en [Fundamentos de R](#r-basics) para saber más sobre la conversión de los tipos de objetos y columnas. 

En primer lugar, vamos a realizar algunas comprobaciones en las columnas importantes para ver si son del tipo correcto. También vimos esto al principio cuando ejecutamos `skim()`. 

Actualmente, el tipo de la columna `age` es un carácter. Para realizar análisis cuantitativos, ¡necesitamos que estos números sean reconocidos como numéricos!. 

```{r}
class(linelist$age)
```

El tipo de la columna `date_onset` ¡también es un carácter! Para realizar los análisis, ¡estas fechas deben ser reconocidas como fechas! 
 
```{r}
class(linelist$date_onset)
```


Para resolver esto, utiliza la capacidad de `mutate()` para redefinir una columna mediante una transformación. Definimos la columna como ella misma, pero convertida a un tipo diferente. He aquí un ejemplo básico, convirtiendo o asegurando que la columna `age` sea de tipo Numeric: 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

De forma similar, puedes utilizar `as.character()` y `as.logical()`. Para convertir al tipo Factor, puedes utilizar `factor()` de R **base** o `as_factor()` de **forcats**. Lee más sobre esto en la página de [Factores](#factors). 

Hay que tener cuidado al convertir al tipo Fecha. En la página [Trabajar con fechas](#working-with-dates-1) se explican varios métodos. Normalmente, los valores de fecha en el fichero crudo deben estar todos en el mismo formato para que la conversión funcione correctamente (por ejemplo, "MM/DD/AAAA", o "DD MM AAAA"). Después de convertir al tipo Fecha, comprueba tus datos para confirmar que cada valor se ha convertido correctamente. 




### Datos agrupados {.unnumbered}  

Si tu dataframe ya está *agrupado* (véase la página sobre [Agrupar datos](#grouping-data)), `mutate()` puede comportarse de forma diferente que si el dataframe no está agrupado. Cualquier función de resumen, como `mean()`, `median()`, `max()`, etc. calculará con datos agrupados, no con filas de registros individualizados.    

```{r, eval=F}
# age normalized to mean of ALL rows
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# age normalized to mean of hospital group
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Lee más sobre el uso de `mutate()` sobre dataframes agrupados en esta [documentación mutate de tidyverse](https://dplyr.tidyverse.org/reference/mutate.html). 



### Transformar múltiples columnas  {#clean_across .unnumbered}

A menudo, para escribir un código conciso, se desea aplicar la misma transformación a varias columnas a la vez. Se puede aplicar una transformación a varias columnas a la vez utilizando la función `across()` del paquete **dplyr** (también contenido en el paquete **tidyverse**). `across()` se puede utilizar con cualquier función **de dplyr**, pero se suele utilizar dentro de `select()`, `mutate()`, `filter()` o `summarise()`. Mira cómo se aplica a `summarise()` en la página sobre [Tablas descriptivas](#descriptive-tables). 

Especificar los argumentos de las columnas `.cols = ` y la(s) función(es) a aplicar a `.fns = `. Cualquier argumento adicional a la función `.fns ` puede incluirse después de una coma, todavía dentro de `across()`.  

#### Selección de columnas con `across()`  {.unnumbered}  

Especificar las columnas de `.cols = `. Puedes nombrarlas individualmente, o utilizar funciones de ayuda "tidyselect". Especifica la función en `.fns = `. Ten en cuenta que, utilizando el modo de función mostrado a continuación, la función se escribe *sin* sus paréntesis (). 

Aquí la transformación `as.character()` se aplica a columnas específicas nombradas dentro de `across()`.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Las funciones de ayuda "tidyselect" están disponibles para ayudarle a especificar las columnas. Se detallan más arriba en la sección sobre Selección y reordenación de columnas, e incluyen: `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` y `any_of()`. 

Este es un ejemplo de cómo se pueden cambiar **todas las columnas** al tipo carácter: 

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Convertir en caracteres todas las columnas cuyo nombre contenga la cadena "date" (fíjate en la colocación de comas y paréntesis): 

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

A continuación, un ejemplo de mutación de las columnas que actualmente son de tipo POSIXct (un tipo datetime cruda que muestra etiquetas) - en otras palabras, donde la función `is.POSIXct()` evalúa a `TRUE`. Entonces queremos convertirlas con la función `as.Date()` en columnas de tipo Date normal. 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

* Ten en cuenta que dentro de `across()` también utilizamos la función `where()` como `is.POSIXct` está evaluando a TRUE o FALSE. 

* Ten en cuenta que `is.POSIXct()` es del paquete **lubridate**. Otras funciones "is" similares como `is.character()`, `is.numeric()`, e `is.logical()` son de R **base** 

#### funciones `across()`  {.unnumbered}

Puedes leer la documentación de ayuda con detalles sobre cómo proporcionar funciones a `across()` escribiendo `?across`: hay varias formas de especificar la(s) función(es) a realizar en una columna e incluso puedes definir tus propias funciones: 

* Puedes escribir el nombre de la función sola (por ejemplo, `mean` o `as.character`) 
* Puedes escribir la función en **estilo purrr** (por ejemplo, `~ mean(.x, na.rm = TRUE)`) (mira [esta página](#iteration-loops-and-lists)) 
* Puedes especificar varias funciones escribiendo una lista (por ejemplo,  `list(mean = mean, n_miss = ~ sum(is.na(.x))`).  * Si proporcionas varias funciones, se devolverán varias columnas     transformadas por cada columna de entrada, con nombres únicos con formato `col_fn`. Puedes ajustar cómo se nombran las columnas nuevas con el argumento `.names = ` utilizando la sintaxis **glue** (mira la página sobre [Caracteres y cadenas](#characters-and-strings)) donde `{.col}` y `{.fn}` son la abreviatura de la columna de entrada y la función. 

Aquí hay algunos recursos en línea sobre el uso de `across()`: [pensamientos/razones del creador Hadley Wickham](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/) 




### `coalesce()` {.unnumbered}  

Esta función de **dplyr** encuentra el primer valor no missing en cada posición. Rellena los valores que faltan con el primer valor disponible en el orden que especifiques. 

Aquí hay un ejemplo *fuera del contexto de un dataframe*: Supongamos que tienes dos vectores, uno que contiene el pueblo de detección del paciente y otro que contiene el pueblo de residencia del paciente. Puedes utilizar coalesce para elegir el primer valor no ausente de cada índice: 

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

Esto funciona de la misma manera si se proporcionan columnas del dataframe: para cada fila, la función asignará el nuevo valor de la columna con el primer valor que no falte en las columnas proporcionadas (en el orden indicado). 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Este es un ejemplo de operación "por filas". Para cálculos más complicados por filas, consulta la sección siguiente sobre cálculos por filas. 



### Matemáticas acumulativas {.unnumbered}

Si deseas que una columna refleje acumulados la sum/mean/min/max, etc., tal y como se ha evaluado en las filas de un dataframe hasta ese punto, utiliza las siguientes funciones: 

`cumsum()` devuelve la suma acumulada, como se muestra a continuación: 

```{r}
sum(c(2,4,15,10))     # returns only one number
cumsum(c(2,4,15,10))  # returns the cumulative sum at each step
```

Esto se puede utilizar en un dataframe al crear una nueva columna. Por ejemplo, para calcular el número acumulado de casos por día en un brote, considere un código como este:  

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # begin with case linelist
  count(date_onset) %>%                 # count of rows per day, as column 'n'   
  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row
```

A continuación se muestran las 10 primeras filas: 

```{r}
head(cumulative_case_counts, 10)
```

Consulta la página sobre [curvas epidémicas](#epidemic-curves) para saber cómo representar la incidencia acumulada con epicurve. 

Véase también:  
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`  





### Utilizando R **base**  {.unnumbered}  

Para definir una nueva columna (o redefinir una columna) utilizando R **base**, escribe el nombre del dataframe, conectado con `$`, a la *nueva* columna (o la columna a modificar). Utiliza el operador de asignación `<-` para definir el nuevo valor o valores. Recuerda que al usar R **base** debes especificar siempre el nombre del dataframe antes del nombre de la columna (por ejemplo, `dataframe$column`). Este es un ejemplo de creación de la columna `bmi` usando R **base**: 

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```



### Añadir a la cadena de tuberías  {.unnumbered}  

**A continuación, se añade una nueva columna a la cadena de tuberías y se convierten algunos tipos.**  

```{r }
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    # add new column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```





## Recodificar valores  {#re-code-values}

A continuación, se presentan algunos escenarios en los que es necesario recodificar (cambiar) los valores: 

* para editar un valor específico (por ejemplo, una fecha con un año o formato incorrecto) 
* para conciliar valores que no se escriben igual 
* para crear una nueva columna de valores categóricos 
* para crear una nueva columna de categorías numéricas (por ejemplo, categorías de edad)  



### Valores específicos  {.unnumbered}  

Para cambiar los valores manualmente puedes utilizar la función `recode()` dentro de la función `mutate()`. 

Imagínate que hay una fecha sin sentido en los datos (por ejemplo, "2014-14-15"): podrías corregir la fecha manualmente en los datos originales, o bien, podrías escribir el cambio en la serie de comandos de limpieza a través de `mutate()` y `recode()`. Esto último es más transparente y reproducible para cualquier otra persona que quiera entender o repetir su análisis. 

```{r, eval=F}
# fix incorrect values                   # old value       # new value
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

La línea `mutate()` anterior puede leerse como: "mutar la columna `date_onset` para que sea igual a la columna `date_onset` recodificada de forma que el VALOR ANTIGUO se cambie por el NUEVO VALOR". Ten en cuenta que este patrón (VIEJO = NUEVO) para `recode()` es el opuesto a la mayoría de los patrones de R (nuevo = viejo). La comunidad de desarrollo de R está trabajando en la revisión de esto. 

**Aquí hay otro ejemplo de recodificación de múltiples valores dentro de una columna.** 

En `linelist` hay que limpiar los valores de la columna "hospital". Hay varias grafías diferentes y muchos valores que faltan. 

```{r}
table(linelist$hospital, useNA = "always")  # print table of all unique values, including missing  
```

El comando `recode()` de abajo redefine la columna "hospital" como la columna actual "hospital", pero con los cambios especificados en la recodificación. ¡No olvides las comas después de cada uno! 

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```


Ahora vemos que se han corregido y consolidado las grafías de la columna `hospital`: 

```{r}
table(linelist$hospital, useNA = "always")
```

<span style="color: darkgreen;">***CONSEJO:*** El número de espacios antes y después de un signo de igualdad no importa. Haz que tu código sea más fácil de leer alineando el signo = para todas o la mayoría de las filas. Además, considera la posibilidad de añadir una fila de comentarios con hash (#) para aclarar a los futuros lectores qué lado es VIEJO y qué lado es NUEVO.  </span>  

<span style="color: darkgreen;">***CONSEJO:*** A veces existe un valor con caracteres *en blanco* en unos datos (no reconocido como valor Missing - `NA` de R. Puedes hacer referencia a este valor con dos comillas sin espacio intermedio (""). </span>  




### Por lógica  {.unnumbered}

A continuación, demostramos cómo recodificar los valores de una columna utilizando lógica y condiciones: 

* Uso de `replace()`, `ifelse()` e `if_else()` para una lógica simple 
* Uso de `case_when()` para una lógica más compleja 
  



### Lógica simple  {.unnumbered}  


#### sustituir con `replace()` {.unnumbered}  

Para recodificar con criterios lógicos simples, puedes utilizar `replace()` dentro de `mutate()`. `replace()` es una función de R **base**. Utiliza una condición lógica para especificar las filas a cambiar. La sintaxis general es: 

`mutate(col_to_change = replace(col_a_cambiar, criterio para filas, nuevo valor))`.  

Una situación frecuente es utilizar `replace()` para **cambiar sólo un valor en una fila, utilizando un identificador de fila único**. A continuación, el género se cambia a "Mujer" en la fila donde la columna `case_id` es "2195".   

```{r, eval=F}
# Example: change gender of one specific observation to "Female" 
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

Abajo se puede ver un ejemplo equivalente utilizando la sintaxis de R **base** y los paréntesis de indexación `[ ]`. Se lee como "Cambia el valor de la columna `gender` del dataframe `linelist` a 'Female'" (para las filas en las que la columna `case_id` de `linelist` tiene el valor '2195').   

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```




#### `ifelse()` e `if_else()` {.unnumbered}  

Otra herramienta para la lógica simple es `ifelse()` y su compañero `if_else()`. Sin embargo, en la mayoría de los casos para la recodificación es más claro utilizar `case_when()` (detallado a continuación). Estos comandos "if else" son versiones simplificadas de una sentencia de programación `if` y `else`. La sintaxis general es:  
`ifelse(condición, valor a devolver si la condición evalúa como TRUE, valor a devolver si la condición evalúa como FALSE)` 

A continuación, se define la columna `source_known`. Su valor en una fila determinada se establece como "known" si *no falta* el valor de la fila en la columna `source`. *Si falta* el valor en `source`, el valor de `source_known` se establece como "unknown". 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()` es una versión especial de **dplyr** que maneja fechas. Ten en cuenta que, si el valor "verdadero" es una fecha, el valor "falso" también debe calificar una fecha, de ahí que se utilice el valor especial `NA_real_` en lugar de simplemente `NA`. 

```{r, eval=F}
# Create a date of death column, which is NA if patient has not died.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**Evita encadenar muchos comandos ifelse... ¡utilza** case_when**() en su lugar!** `case_when()` es mucho más fácil de leer y cometerás menos errores.   

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Fuera del contexto de un dataframe, si deseas que un objeto utilizado en su código cambie su valor, considere el uso de `switch()` de R **base**. 



### Lógica compleja  {#clean_case_when .unnumbered}  

Utiliza `case_when()` de **dplyr** si estás recodificando en muchos grupos nuevos, o si necesita utilizar sentencias lógicas complejas para recodificar valores. Esta función evalúa si cada fila del dataframe cumple los criterios especificados y asigna el nuevo valor correcto. 

Los comandos `case_when()` consisten en sentencias que tienen un lado derecho (RHS) y un lado izquierdo (LHS) separados por una "tilde" `~` (cola de chancho). Los criterios lógicos están en el lado izquierdo y los valores de conformidad están en el lado derecho de cada sentencia. Las declaraciones están separadas por comas. 

Por ejemplo, aquí utilizamos las columnas `age` y `age_unit` para crear una columna `age_years`: 


```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```


A medida que se evalúa cada fila de los datos, los criterios se aplican/evalúan en el orden en que se escriben las sentencias `case_when()`, de arriba a abajo. Si el criterio superior se evalúa como `TRUE` para una fila determinada, se asigna el valor RHS, y los criterios restantes ni siquiera se prueban para esa fila. Por lo tanto, es mejor escribir los criterios más específicos primero y los más generales al final. 

En esta línea, en su declaración final, coloca `TRUE` en el lado izquierdo, lo que capturará cualquier fila que no cumpla ninguno de los criterios anteriores. Al lado derecho de esta declaración se le podría asignar un valor como "¡comprobado!" o faltante.  


<span style="color: red;">***PELIGRO:* Los valores del lado derecho deben ser todos del mismo tipo**: numéricos, de caracteres, de fecha, lógicos, etc. Para asignar faltantes (`NA`), puede ser necesario utilizar variaciones especiales de `NA` como `NA_character_`, `NA_real_` (para numérico o POSIX), y `as.Date(NA)`. Lee más en [Trabajar con fechas](#working-with-dates-1). </span>  




### Valores faltantes {.unnumbered} 

A continuación, se presentan funciones especiales para el tratamiento de los valores faltantes en el contexto de la limpieza de datos. 

Consulta la página sobre [Valores faltantes](#missing-data) para obtener consejos más detallados sobre la identificación y el tratamiento de los valores faltantes. Por ejemplo, la función `is.na()` que comprueba lógicamente la ausencia de datos. 


**`replace_na()`**  

Para cambiar los valores faltantes (`NA`) por un valor específico, como "Missing", utiliza la función de **dplyr** `replace_na()` dentro de `mutate()`. Ten en cuenta que se utiliza de la misma manera que recodificar anteriormente - el nombre de la variable debe repetirse dentro de `replace_na()`.  

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```


**fct_explicit_na()**  

Esta es una función del paquete **forcats**. El paquete **forcats** maneja columnas del tipo Factor. Los factores son la forma en que R maneja valores *ordenados* como `c("First", "Second", "Third")` o para establecer el orden en que los valores (por ejemplo, hospitales) aparecen en las tablas y gráficos. Vea la página sobre [Factores](#factors). 

Si tus datos son del tipo Factor y tratas de convertir `NA` en "Missing" utilizando `replace_na()`, obtendrás este error: `invalid factor level, NA generated` (nivel de factor no válido, NA generado). Has intentado añadir "Missing" como valor, cuando no estaba definido como un posible nivel del factor, y ha sido rechazado. 

La forma más fácil de resolver esto es utilizar la función `fct_explicit_na()` de  **forcats** que convierte una columna en factor de tipo, y convierte los valores `NA` en el carácter "(Missing)".  

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Una alternativa más lenta sería añadir el nivel del factor utilizando `fct_expand()` y luego convertir los valores que faltan.   

**`na_if()`**  

Para convertir un *valor específico en* `NA`, utiliza `na_if()` de **dplyr**. El comando siguiente realiza la operación opuesta a `replace_na()`. En el siguiente ejemplo, cualquier valor de "Missing" en la columna `hospital` se convierte en `NA`. 

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Nota: `na_if()` **no puede utilizarse para criterios lógicos** (por ejemplo, "todos los valores > 99") - utiliza `replace()` o `case_when()` para ello:  

```{r, eval=F}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```




### Diccionario de limpieza  {.unnumbered}

Utiliza el paquete R **linelist** y su función `clean_variable_spelling()` para limpiar un dataframe con un *diccionario de limpieza*. **linelist** es un paquete desarrollado por [RECON](https://github.com/reconhub/linelist) - el  R Epidemics Consortium. 

1.  Crear un diccionario de limpieza con 3 columnas:  
     * Una columna "desde" (el valor incorrecto)  
     * Una columna "para" (el valor correcto)  
     * Una columna que especifica la columna a la que se aplicarán los cambios (o ".global" para aplicarlo a todas las columnas) 

Nota: Las entradas del diccionario .global serán anuladas por las entradas del diccionario específico de la columna. 

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```


2.  Importa el archivo del diccionario a R. Este ejemplo puede descargarse a través de las instrucciones de la página [Descargar manual y datos](#download-handbook-and-data).   

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3.  Pasa linelist crudas a `clean_variable_spelling()`, especificando en `wordlists = ` el dataframe del diccionario de limpieza. El argumento `spelling_vars = ` puede utilizarse para especificar a qué columna del diccionario se refieren las columnas (la tercera por defecto), o puede establecerse como `NULL` para que el diccionario se aplique a todas las columnas de caracteres y factores. Ten en cuenta que esta función puede tardar mucho en ejecutarse. 

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # dict column containing column names, defaults to 3rd column in dict
  )
```

Ahora desplázate a la derecha para ver cómo han cambiado los valores - en particular el `gender` (de minúsculas a mayúsculas), y todas las columnas de síntomas se han transformado de sí/no a 1/0. 

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Ten en cuenta que los nombres de las columnas en el diccionario de limpieza deben corresponder a los nombres *en este punto* de tu script de limpieza. Consulta esta [referencia en línea para el paquete linelist](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) para obtener más detalles. 






#### Añadir a la cadena de tuberías {.unnumbered}  

**A continuación, se añaden algunas columnas y transformaciones de columna nuevas a la cadena de tuberías.** 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
   ###################################################

    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Categorías numéricas  {#num_cats}

Aquí describimos algunos enfoques especiales para crear categorías a partir de columnas numéricas. Algunos ejemplos comunes son las categorías de edad, los grupos de valores de laboratorio, etc. Aquí discutiremos: 

* `age_categories()`, del paquete **epikit**  
* `cut()`, de R **base**
* `case_when()`  
* ruptura de cuantiles con `quantile()` y `ntile()` 


### Revisión de la distribución {.unnumbered}

Para este ejemplo crearemos una columna `age_cat` utilizando la columna `age_years.` 

```{r}
#check the class of the linelist variable age
class(linelist$age_years)
```

En primer lugar, examina la distribución de tus datos, para hacer los puntos de corte apropiados. Consulta la página sobre [Conceptos básicos de ggplot](#ggplot-basics).  

```{r, out.height='50%'}
# examine the distribution
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

<span style="color: orange;">***ATENCIÓN:*** A veces, las variables numéricas se importarán como tipo "carácter". Esto ocurre si hay caracteres no numéricos en algunos de los valores, por ejemplo, una entrada de "2 meses" para la edad, o (dependiendo de la configuración de su configuración local de R) si se utiliza una coma en el lugar de los decimales (por ejemplo, "4,5" para significar cuatro años y medio). </span>


<!-- ======================================================= -->
### `age_categories()` {.unnumbered}

Con el paquete **epikit**, puedes utilizar la función `age_categories()` para categorizar y etiquetar fácilmente las columnas numéricas (nota: esta función puede aplicarse también a las variables numéricas no relacionadas con la edad). Además, la columna de salida es automáticamente un factor ordenado. 

Aquí están las entradas requeridas: 

* Un vector numérico (columna) 
* El argumento + breakers = ` - proporciona un vector numérico de puntos de ruptura para los nuevos grupos 

Primero, el ejemplo más sencillo:   

```{r}
# Simple example
################
pacman::p_load(epikit)                    # load package

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# show table
table(linelist$age_cat, useNA = "always")
```

Los valores de ruptura que especificas son por defecto los límites inferiores - es decir, están incluidos en el grupo "superior" / los grupos están "abiertos" en la parte inferior/izquierda. Como se muestra a continuación, puedes añadir 1 a cada valor de ruptura para conseguir grupos que estén abiertos por la parte superior/derecha. 
 
```{r}
# Include upper ends for the same categories
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# show table
table(linelist$age_cat, useNA = "always")
```


Puedes ajustar cómo se muestran las etiquetas con el `separator = `. El valor predeterminado es "-" 

Puedes ajustar cómo se manejan los números superiores, con el argumento `ceiling = `. Para establecer un corte superior establezca `ceiling = TRUE`. En este uso, el valor de ruptura más alto proporcionado es un "techo" y no se crea una categoría "XX+". Cualquier valor por encima del valor de corte más alto (o hasta el límite  `upper = `, si está definido) se categoriza como `NA`. A continuación, se muestra un ejemplo con `ceiling = TRUE`, de modo que no hay categoría de XX+ y los valores por encima de 70 (el valor de ruptura más alto) se asignan como `NA`. 

```{r}
# With ceiling set to TRUE
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# show table
table(linelist$age_cat, useNA = "always")
```

Alternativamente, en lugar de los `breakers = `, puedes proporcionar todos los `lower = `, `upper = `, and `by = `: 

* `lower = ` El número más bajo que se quiere considerar - por defecto es 0 
* `upper = ` El número más alto que quiere que se considere   
* `by = `    El número de años entre los grupos 

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# show table
table(linelist$age_cat, useNA = "always")
```


Consulta la página de ayuda de la función para más detalles (escribe `?age_categories` en la consola de R). 


<!-- ======================================================= -->
### `cut()` {.unnumbered}

`cut()` es una alternativa a `age_categories()` de R **base**, pero creo que verás por qué `age_categories()` se desarrolló para simplificar este proceso. Algunas diferencias notables de `age_categories()` son: 

* No es necesario instalar/cargar otro paquete 
* Puedes especificar si los grupos están abiertos/cerrados a la derecha/izquierda 
* Debes proporcionar etiquetas precisas 
* Si quieres que el 0 se incluya en el grupo más bajo debes especificarlo 

La sintaxis básica dentro de `cut()` es proporcionar primero la columna numérica que se va a cortar (`age_years`), y luego el argumento *breaks*, que es un vector numérico `c()` de puntos de ruptura. Utilizando `cut()`, la columna resultante es un factor ordenado. 

Por defecto, la categorización se produce de manera que el lado derecho/superior es "abierto" e inclusivo (y el lado izquierdo/inferior es "cerrado" o exclusivo). Este es el comportamiento opuesto al de la función `age_categories()`. Las etiquetas por defecto utilizan la notación "(A, B]", lo que significa que A no está incluido pero B sí. **Invierte este comportamiento proporcionando el argumento right = TRUE**. 

Así, por defecto, ¡los valores "0" se excluyen del grupo más bajo, y se categorizan como `NA`! Los valores "0" podrían ser codificados para los bebés como edad 0, así que ¡ten cuidado! Para cambiar esto, añade el argumento `include.lowest = TRUE`  para que cualquier valor "0" se incluya en el grupo más bajo. La etiqueta generada automáticamente para la categoría más baja será entonces "[A],B]". Ten en cuenta que si incluye el argumento `include.lowest = TRUE` **y** `right = TRUE`, la inclusión extrema se aplicará ahora al valor del punto de ruptura y a la categoría *más altos*, no a los más bajos. 

Puedes proporcionar un vector de etiquetas personalizadas utilizando el argumento `labels = `. Como se escriben manualmente, ¡ten mucho cuidado de que sean precisas! Comprueba el trabajo utilizando una tabulación cruzada, como se describe a continuación. 

A continuación se muestra un ejemplo de `cut()` aplicado a `age_years` para crear la nueva variable `age_cat`: 

```{r}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```


**¡Comprueba tu trabajo!** Verifica que cada valor de edad fue asignado a la categoría correcta cruzando las columnas numéricas y de categoría. Examina la asignación de los valores límite (por ejemplo, 15, si las categorías vecinas son 10-15 y 16-20). 

```{r}
# Cross tabulation of the numeric and category columns. 
table("Numeric Values" = linelist$age_years,   # names specified in table for clarity.
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # don't forget to examine NA values
```





**Re-etiquetado de los valores `NA`** 

Puedes asignar a los valores `NA` una etiqueta como "Missing". Como la nueva columna es del tipo Factor (valores restringidos), no puedes simplemente mutarla con `replace_na()`, ya que este valor será rechazado. En su lugar, utilice `fct_explicit_na()` de **forcats** como se explica en la página de [Factores](#factors).   

```{r}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

**Realiza rápidamente pausas y etiquetas** 

Para una forma rápida de hacer rupturas y etiquetar vectores, utiliza algo como lo siguiente. Consulta la página de [fundamentos de R](#r-basics) para obtener referencias sobre `seq()` y `rep()`. 

```{r, eval=F}
# Make break points from 0 to 90 by 5
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Make labels for the above categories, assuming default cut() settings
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# check that both vectors are the same length
length(age_seq) == length(age_labels)
```


Lee más sobre `cut()` en la página de ayuda escribiendo `?cut` en la consola de R.  




### Roturas cuartílicas  {.unnumbered}  

En el entendimiento común, los "cuartiles" o "percentiles" suelen referirse a un valor por debajo del cual cae una proporción de valores. Por ejemplo, el percentil 95 de las edades en `linelist` sería la edad por debajo de la cual cae el 95% de las edades. 

Sin embargo, en el lenguaje común, "cuartiles" y "deciles" también pueden referirse a los *grupos de datos* divididos por igual en 4 o 10 grupos (Ten en cuenta que habrá un punto de ruptura más que un grupo). 

Para obtener los puntos de ruptura de los cuartiles, se puede utilizar `quantile()` del paquete **stats** de R **base.** Se proporciona un vector numérico (por ejemplo, una columna en unos datos) y un vector de valores de probabilidad numérica que van de 0 a 1,0. Los puntos de ruptura se devuelven como un vector numérico. Explore los detalles de las metodologías estadísticas escribiendo `?quantile.` 

* Si su vector numérico de entrada tiene valores faltantes, es mejor establecer `na.rm = TRUE` 
* Establecer `names = FALSE` para obtener un vector numérico sin nombre 

```{r}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

Puedes utilizar los resultados de `quantile()` como puntos de ruptura en `age_categories()` o `cut()`. A continuación creamos una nueva columna `deciles` utilizando `cut()` donde los puntos de ruptura se definen utilizando `quantiles()` en `age_years`. A continuación, mostramos los resultados utilizando `tabyl()` de **janitor** para que puedas ver los porcentajes (véase la página de [tablas descriptivas](#descriptive-tables)). Observa cómo no son exactamente el 10% en cada grupo. 

```{r}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

### Grupos de tamaño uniforme  {.unnumbered}  

Otra herramienta para hacer grupos numéricos es la función `ntile()` de **dplyr**, que intenta dividir los datos en n *grupos de tamaño uniforme -* pero ten en cuenta que, a diferencia de *quantile(),* el mismo valor podría aparecer en más de un grupo*.* Proporcione el vector numérico y luego el número de grupos. Los valores de la nueva columna creada son sólo "números" de grupo (por ejemplo, del 1 al 10), no el rango de valores en sí mismo como cuando se utiliza `cut()`. 

```{r}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")
```


<!-- ======================================================= -->
### `case_when()` { .unnumbered}

Es posible utilizar la función `case_when()` de **dplyr** para crear categorías a partir de una columna numérica, pero es más fácil utilizar `age_categories()` de **epikit** o `cut()` porque éstas crearán un factor ordenado automáticamente. 

Si utilizas `case_when()`, por favor, revise el uso adecuado como se ha descrito anteriormente en la sección Re-codificar valores de esta página. También Ten en cuenta que todos los valores del lado derecho deben ser del mismo tipo. Por lo tanto, si quiere `NA` en el lado derecho debes escribir "Missing" o utilizar el valor especial `NA_character_`. 


### Añadir a la cadena de tuberías {.unnumbered}  

A continuación, se añade el código para crear dos columnas categóricas de edad a la cadena de tuberías de limpieza: 

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################   
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```








<!-- ======================================================= -->
## Añadir filas {#add-rows}

### Uno a uno  {.unnumbered}  

Añadir filas una a una manualmente es tedioso pero puede hacerse con `add_row()` de **dplyr**. Recuerda que cada columna debe contener valores de un solo tipo (ya sea carácter, numérico, lógico, etc.). Así que añadir una fila requiere matizar para mantener esto. 

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

Utiliza `.before` y `.after`. para especificar la ubicación de la fila que deseas añadir. `.before = 3` pondrá la nueva fila antes de la tercera fila actual. El comportamiento por defecto es añadir la fila al final. Las columnas no especificadas se dejarán vacías (`NA`). 

El nuevo *número de fila* puede parecer extraño ("...23") pero los números de fila de las filas preexistentes *han* cambiado. Por lo tanto, si utiliza el comando dos veces, examine/pruebe la inserción cuidadosamente. 

Si uno de los tipos que proporcionas está desactivado, verás un error como este: 

```
Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.
```

(al insertar una fila con un valor de fecha, recuerde envolver la fecha en la función `as.Date()` como `as.Date("2020-10-10")`). 


### Unir filas  {.unnumbered}  

Para combinar conjuntos de datos uniendo las filas de un dataframe al final de otro dataframe, puedes utilizar `bind_rows()` de **dplyr**. Esto se explica con más detalle en la página [Unir datos](#joining-data).




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Filtrar filas  {#filter-rows}


Un paso típico de limpieza después de haber limpiado las columnas y recodificado los valores es *filtrar* el dataframe para filas específicas usando el verbo **dplyr** `filter()`. 

Dentro de `filter()`, especifique la lógica que debe ser `TRUE` para que se mantenga una fila en los datos. A continuación, mostramos cómo filtrar filas basándose en condiciones lógicas simples y complejas.  



<!-- ======================================================= -->
### Filtro simple  {.unnumbered} 

Este sencillo ejemplo redefine el dataframe `linelist` en sí mismo, habiendo filtrado las filas para que cumplan una condición lógica. **Sólo se conservan las filas en las que la declaración lógica dentro de los paréntesis se evalúa como TRUE.** 

En este ejemplo, la sentencia lógica es `gender == "f"`, que pregunta si el valor de la columna `gender` es igual a "f" (distingue entre mayúsculas y minúsculas). 

Antes de aplicar el filtro, el número de filas de `linelist` es ` nrow(linelist)`. 

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # keep only rows where gender is equal to "f"
```

Después de aplicar el filtro, el número de filas de `linelist` is ` linelist %>% filter(gender == "f") %>% nrow()`. 


### Filtrar los valores faltantes  {.unnumbered}  

Es bastante común querer filtrar las filas que tienen valores faltantes. Resiste la tentación de escribir `filter(!is.na(column) & !is.na(column))` y utiliza en su lugar la función de tidyr que está hecha a medida para este propósito: drop_na(). Si se ejecuta con paréntesis vacíos, elimina las filas con *cualquier* valor que falte. Como alternativa, puedes proporcionar los nombres de las columnas específicas que deben evaluarse para comprobar si faltan, o utilizar las funciones de ayuda "tidyselect" descritas [anteriormente](#clean_tidyselect).  

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Consulta la página sobre [Valores faltantes](#missing-data) para conocer muchas técnicas para analizar y gestionar los datos ausentes. 




### Filtrar por número de fila  {.unnumbered}  

En un dataframe o tibble, cada fila suele tener un "número de fila" que (cuando se ve en R Viewer) aparece a la izquierda de la primera columna. No es en sí misma una columna real en los datos, pero puede utilizarse en una sentencia `filter()`. 

Para filtrar en base al "número de fila", puedes utilizar la función `row_number()` de **dplyr** con paréntesis abiertos como parte de una sentencia lógica de filtrado. A menudo se utiliza el operador `%in%` y un rango de números como parte de esa sentencia lógica, como se muestra a continuación. Para ver las *primeras* N filas, también puedes utilizar la función especial `head()` de **dplyr**.  

```{r, eval=F}
# View first 100 rows
linelist %>% head(100)     # or use tail() to see the n last rows

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

También puedes convertir los números de fila en una verdadera columna pasando su dataframe a la función `rownames_to_column()` de **tibble** (no escribas nada en los paréntesis). 


<!-- ======================================================= -->
### Filtro complejo  {.unnumbered} 

Se pueden construir sentencias lógicas más complejas utilizando paréntesis `( )`, OR `|`, negación `!` , `%in%`, y operadores AND `&`. Un ejemplo es el siguiente: 

Nota: Puedes utilizar el operador `!` delante de un criterio lógico para negarlo. Por ejemplo, `!is.na(column)` se evalúa como verdadero si el valor de la columna *no* falta. Del mismo modo, `!column %in% c("a", "b", "c")` es verdadero si el valor de la columna *no está* en el vector.  


#### Examinar los datos  {.unnumbered}  

A continuación, se muestra un sencillo comando de una línea para crear un histograma de las fechas de inicio. Vea que un segundo brote más pequeño de 2012-2013 también está incluido en este conjunto de datos sin procesar. **Para nuestros análisis, queremos eliminar las entradas de este brote anterior.**  

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```


#### ¿Cómo manejan los filtros los valores numéricos y de fecha que faltan? {.unnumbered}  
 
¿Podemos simplemente filtrar por `date_onset` a las filas posteriores a junio de 2013? **Precaución. La aplicación del código `filter(date_onset > as.Date("2013-06-01"))` eliminaría todas las filas de la epidemia posterior con una fecha de inicio ausente!** 

<span style="color: red;">***PELIGRO:*** Filtrar a mayor que (>) o menor que (<) una fecha o número puede eliminar cualquier fila con valores faltantes (`NA`). Esto se debe a que `NA` es tratado como infinitamente grande y pequeño. </span>

*(Consulta la página sobre el [trabajando con fechas](#working-with-dates) para obtener más información sobre el trabajo con fechas y el paquete **lubridate**)* 

#### Diseñar el filtro {.unnumbered}  

Examina una tabulación cruzada para asegurarte de que excluimos sólo las filas correctas:  


```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

¿Qué otros criterios podemos filtrar para eliminar el primer brote (en 2012 y 2013) de los datos? Vemos que: 

* La primera epidemia en 2012 y 2013 ocurrió en el Hospital A, el Hospital B, y que también hubo 10 casos en el Hospital del Puerto. 
* Los hospitales A y B *no* tuvieron casos en la segunda epidemia, pero Port Hospital sí. 

Queremos excluir: 

* Las filas con inicio en 2012 y 2013 en cualquiera de los hospitales A, B o Port `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` :  
  * Excluir `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))` filas con inicio en 2012 y 2013   * Excluir `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` filas de los hospitales A y B con fechas de inicio ausentes  
  * **No** excluir `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` otras filas con fechas de inicio ausentes. 

Comenzamos con un listado de `nrow(linelist)`. Aquí está nuestro filtro: 

```{r}
linelist <- linelist %>% 
  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Cuando volvemos a hacer la tabulación cruzada, vemos que los hospitales A y B se eliminan por completo, y los 10 casos del Port Hospital de 2012 y 2013 se eliminan, y todos los demás valores son los mismos, tal y como queríamos. 
 
```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Se pueden incluir varias sentencias dentro de un comando de filtrado (separadas por comas), o siempre se puede canalizar a un comando `filter()` separado para mayor claridad. 

*Nota: algunos lectores pueden notar que sería más fácil filtrar sólo por date_hospitalisation porque es 100% completo sin valores faltantes. Esto es cierto. Pero date_onset se utiliza para demostrar un filtro complejo.* 




### Independiente  {.unnumbered}  

El filtrado también puede realizarse como un comando independiente (no como parte de una cadena de tuberías). Como otros verbos de **dplyr**, en este caso el primer argumento debe ser el propio conjunto de datos.   

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

También puedes utilizar R **base** para hacer un subconjunto utilizando corchetes que reflejen las [filas, columnas] que deseas conservar.  

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```





### Revisar rápidamente los registros  {.unnumbered} 

A menudo se quiere revisar rápidamente unos pocos registros, para sólo unas pocas columnas. La función View() de R **base** imprimirá un dataframe para su visualización en su RStudio. 

Mira el listado en RStudio: 

```{r, eval=F}
View(linelist)
```

Aquí hay dos ejemplos de visualización de celdas específicas (filas específicas y columnas específicas): 

**Con las funciones `filter()` y `select()` de dplyr :**

Dentro de `View()`, canaliza los datos a `filter()` para mantener ciertas filas, y luego a `select()` para mantener ciertas columnas. Por ejemplo, para revisar las fechas de inicio y hospitalización de 3 casos específicos: 

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```


Puedes lograr lo mismo con la sintaxis de R **base**, utilizando los corchetes `[ ]` para el subconjunto que deseas ver. 

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```





#### Añadir a la cadena de pipes  {.unnumbered}  


```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    filter(
          # keep only rows where case_id is not missing
          !is.na(case_id),  
          
          # also filter to keep only the second outbreak
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```







<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Cálculos por filas   {#row-wise-calculations}

Si deseas realizar un cálculo dentro de una fila, puedes utilizar `rowwise()` de **dplyr**. Consulta esta viñeta en línea sobre los cálculos [por filas](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html). Por ejemplo, este código aplica `rowwise()` y luego crea una nueva columna que suma el número de las columnas de síntomas especificadas que tienen valor "yes", para cada fila Las columnas se especifican dentro de `sum()` por su nombre dentro de un vector `c()`. `rowwise()` es esencialmente un tipo especial de `group_by()`, por lo que es mejor utilizar `ungroup()` cuando hayas terminado (página sobre [Agrupar datos](#grouping-data)). 

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display
```

  
Al especificar la columna a evaluar, puedes utilizar las funciones de ayuda "tidyselect" descritas en la sección `select()` de esta página. Sólo tiene que hacer un ajuste (porque no las está utilizando dentro de una función **de dplyr** como `select()` o `summarise()`). 

Especifica los criterios de la columna dentro de la función `c_across()` de **dplyr**. Esto se debe a que c_across ([documentación](https://dplyr.tidyverse.org/reference/c_across.html)) está diseñada para trabajar con `rowwise()` específicamente. Por ejemplo, el siguiente código: 

* Utiliza `rowwise()` para que la siguiente operación (`sum()`) se aplique dentro de cada fila (no sumando columnas enteras) 
* Crea una nueva columna `num_NA_dates`, definida para cada fila como el número de columnas (con nombre que contiene "date") para las que `is.na()` se evaluó como TRUE (son valores faltantes). 
* `ungroup()` para eliminar los efectos de `rowwise()` en los pasos siguientes  

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

También podrías proporcionar otras funciones, como `max()` para obtener la fecha más reciente o más reciente de cada fila:  

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```


## Ordenar y clasificar {#arrange-and-sort}

Utiliza la función arrange() de **dplyr** para ordenar las filas por los valores de las columnas. 

Lista las columnas en el orden en que deben ser ordenadas. Especifica `.by_group = TRUE` si deseas que la ordenación se realice primero por cualquier *agrupación* aplicada a los datos (véase la página sobre [Agrupar datos](#grouping-data)). 

Por defecto, la columna se ordenará en orden "ascendente" (que se aplica a las columnas numéricas y también a las de caracteres). Puedes ordenar una variable en orden "descendente" envolviéndola con `desc()`. 

La ordenación de los datos con `arrange()` es particularmente útil cuando se hacen [Tablas para presentaciones](#tables-for-presentation), utilizando `slice()` para tomar las filas "superiores" por grupo, o estableciendo el orden de los niveles de los factores por orden de aparición. 

Por ejemplo, para ordenar las filas de nuestro `linelist` por `hospital` y luego por `date_onset` (fecha de inicio) en orden descendente, utilizaríamos:  

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```


```{r, echo=F}
# HIDDEN
#
# convert one remaining old outbreak row to missing for ease
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```



```{r echo=F}
# REARRANGE COLUMNS FOR EXPORT
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# EXPORT CLEANED LINELIST FILE TO "DATA" FOLDER
#jfmont rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
